---
description: Cursor rules for TypeScript project
globs:
alwaysApply: true
---

# ğŸ—ï¸ TYPESCRIPT PROJECT

## ğŸ—ï¸ ARCHITECTURE DECISIONS

### Hexagonal Architecture (Clean Architecture)

- Use hexagonal architecture pattern for all modules
- Structure: domain/ â†’ application/ â†’ adapters/
- Domain layer: Pure business logic, entities, value objects, events
- Application layer: Use cases, services, repository interfaces
- Adapters layer: Infrastructure implementations (database, API clients, external services)

### Function-First Philosophy

**CRITICAL**: This project follows a **function-first approach** where:

- **Classes are ONLY used for**:
  - Domain entities with behavior
  - Rich value objects with validation
  - Domain events
  - Domain errors extending Error
- **Functions are used for EVERYTHING else**:
  - Use cases (factory functions)
  - Application services (factory functions)
  - Repositories (factory functions)
  - Infrastructure adapters (factory functions)
  - Utilities and helpers (pure functions)

- **Dependency injection is function-based**:
  - Dependencies are passed as function parameters
  - No constructor injection or class-based DI
  - Services return objects with methods
  - Easy to test and compose

```typescript
// âœ… Correct pattern: Function-based use case
export const createUser =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserInput): Promise<User> => {
    // Implementation
  };

// âŒ Incorrect pattern: Class-based use case
export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {} // âŒ Avoid
}
```

### Directory Structure

```
project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domain/                   # Pure business logic
â”‚   â”‚   â”œâ”€â”€ models/               # Domain entities (with Zod validation)
â”‚   â”‚   â”œâ”€â”€ value-objects/        # Immutable value objects
â”‚   â”‚   â”œâ”€â”€ events/               # Domain events
â”‚   â”‚   â”œâ”€â”€ errors/               # Domain-specific errors
â”‚   â”‚   â””â”€â”€ ports/                # Interfaces (ports) for repositories and external services
â”‚   â”‚
â”‚   â”œâ”€â”€ application/              # Use cases and orchestration
â”‚   â”‚   â”œâ”€â”€ use-cases/            # Business use-case implementations
â”‚   â”‚   â”œâ”€â”€ dto/                  # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ services/             # Application services (orchestrators)
â”‚   â”‚   â””â”€â”€ ports/                # Interfaces required by use cases (driven ports)
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/           # Concrete adapters
â”‚   â”‚   â”œâ”€â”€ persistence/          # Database adapters (ORMs, driversâ€¦)
â”‚   â”‚   â”œâ”€â”€ messaging/            # Message-queue adapters
â”‚   â”‚   â”œâ”€â”€ external/             # Third-party service adapters (APIs, SDKsâ€¦)
â”‚   â”‚   â””â”€â”€ di/                   # Dependency-injection container setup
â”‚   â”‚
â”‚   â”œâ”€â”€ interfaces/               # Driven adapters (entry points)
â”‚   â”‚   â”œâ”€â”€ http/                 # HTTP controllers, routes, middleware
â”‚   â”‚   â”œâ”€â”€ cli/                  # CLI commands
â”‚   â”‚   â”œâ”€â”€ grpc/                 # gRPC handlers
â”‚   â”‚   â””â”€â”€ events/               # Event listeners (Kafka, RabbitMQâ€¦)
â”‚   â”‚
â”‚   â”œâ”€â”€ shared/                   # Cross-cutting utilities
â”‚   â”‚   â”œâ”€â”€ config/               # Env-var loading, config schemas
â”‚   â”‚   â”œâ”€â”€ logger/               # Central logger (e.g. Pino, Winston)
â”‚   â”‚   â””â”€â”€ utils/                # Generic helpers (date utils, transformersâ€¦)
â”‚   â”‚
â”‚   â”œâ”€â”€ config/                   # Project configs (ORM, ESLint, Jestâ€¦)
â”‚   â”‚   â”œâ”€â”€ ormconfig.ts
â”‚   â”‚   â”œâ”€â”€ logger.config.ts
â”‚   â”‚   â””â”€â”€ â€¦
â”‚   â”‚
â”‚   â”œâ”€â”€ __fixtures__/             # Test fixtures and builders
â”‚   â””â”€â”€ index.ts                  # Application entry point
â”‚
â”œâ”€â”€ tests/                        # Integration & end-to-end tests
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚   â””â”€â”€ evaluations/
â”‚
â”œâ”€â”€ docs/                         # Documentation (architecture diagrams, OpenAPIâ€¦)
â”‚
â”œâ”€â”€ scripts/                      # Utility scripts (migrations, seedersâ€¦)
â”‚
â”œâ”€â”€ .env                          # Default environment variables
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

## ğŸ’» CODE STYLE & CONVENTIONS

### File Naming

- Use kebab-case for all files in ./src
- Each module should have meaningful descriptive names
- Tests: place .test.ts files next to implementation files
- Integration tests: use .integ-test.ts suffix
- E2E tests: use .e2e-test.ts suffix

### TypeScript Imports

- **CRITICAL**: Always use path aliases (@/) instead of relative imports (../ or ./)
- **CRITICAL**: Never add .js extensions to TypeScript imports
- Use configured path aliases:
  - `@/*` - Root src directory
  - `@adapters/*` - Adapter implementations
  - `@application/*` - Application layer
  - `@domain/*` - Domain layer
  - `@evaluations/*` - Evaluation tests
  - `@fixtures/*` - Test fixtures
- TypeScript handles extensions automatically during transpilation

### Import Patterns

```typescript
// âœ… Correct imports (use path aliases)
import { User } from '@domain/entities/user';
import { createUserProfile } from '@application/use-cases/createUserProfile';
import { getAuroraClient } from '@adapters/database/clients/auroraClient';
import { logger } from '@adapters/shared/logger';
import { config } from '@/config';

// âŒ Incorrect imports (relative paths)
import { User } from '../domain/entities/user';
import { createUserProfile } from './use-cases/createUserProfile';
import { getAuroraClient } from '../../adapters/database/clients/auroraClient';
```

### Entity & Schema Patterns

```typescript
// âœ… Use Zod schemas for validation
import { z } from 'zod';

export const userSchema = z.object({
  id: z.number(),
  companyId: z.number(),
  name: z.string().max(64),
  email: z.string().email(),
  // ... other fields
});

export type User = z.infer<typeof userSchema>;
```

### Use Case Patterns

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

## ğŸ§ª TESTING STRATEGY

### Test Architecture

- **Unit tests**: `npm run test:unit` (fast, isolated)
- **Integration tests**: `npm run test:integ` (with real dependencies)
- **E2E tests**: `npm run test:e2e` (full system tests)
- **Evaluation tests**: `npm run test:eval` (AI model evaluations)
- Use Vitest as testing framework

### Test Patterns

```typescript
// âœ… Use builders for test data
import { userBuilder } from '@fixtures/user.fixture';
import { randomNumber } from '@fixtures/utils.fixture';

describe('createUserProfile', () => {
  it('should create user profile successfully', async () => {
    // Arrange
    const user = userBuilder.build();
    const companyId = randomNumber();

    // Act
    const result = await useCase({ userId: user.id, companyId });

    // Assert
    expect(result.isSuccess).toBe(true);
  });
});
```

### Test File Organization

- Unit tests: `*.test.ts` next to implementation
- Integration tests: `*.integ-test.ts` in same directory
- E2E tests: `*.e2e-test.ts` in same directory
- Use `__fixtures__/` for shared test data and builders

## ğŸ› ï¸ CODE QUALITY TOOLS

### ESLint Configuration

- Uses TypeScript ESLint with strict rules
- Enforces arrow functions over function declarations
- No console.log allowed (use logger instead)

### Key ESLint Rules

```typescript
// âœ… Correct patterns
const useCase = (dependencies) => async (input) => {
  /* ... */
};

logger.info('Message', { context });

// âŒ Avoid these patterns
function useCase() {
  /* ... */
} // Use arrow functions
console.log('message'); // Use logger instead
```

## ğŸ”„ FUNCTIONAL PROGRAMMING PATTERNS

### Function-First Architecture

This project follows a **function-first approach** where classes are avoided in favor of functions, dependency injection, and TypeScript types.

#### When to Use Classes vs Functions

```typescript
// âœ… Use classes ONLY for domain entities and value objects
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string
  ) {}

  updateName(newName: string): User {
    return new User(this.id, this.email, newName);
  }
}

// âœ… Use classes for domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// âœ… Use FUNCTIONS for everything else: use cases, services, repositories
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

// âœ… Use TYPES/INTERFACES for contracts
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
}

// âŒ DON'T use classes for services, repositories, or use cases
export class UserService {
  constructor(private userRepository: UserRepository) {} // âŒ Avoid

  async createUser(input: CreateUserInput): Promise<User> {
    // âŒ Avoid this pattern
  }
}
```

#### Functional Dependency Injection

```typescript
// âœ… Function-based dependency injection
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
  },

  sendPasswordReset: async (email: string) => {
    // Implementation
  },
});

// âœ… Export type for dependency injection
export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;

// âŒ DON'T use class-based dependency injection
export class UserNotificationService {
  constructor(
    private userRepository: UserRepository, // âŒ Avoid
    private emailService: EmailService, // âŒ Avoid
    private logger: Logger // âŒ Avoid
  ) {}
}
```

#### Repository Pattern with Functions

```typescript
// âœ… Function-based repository implementation
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },
});

// âŒ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {} // âŒ Avoid

  async create(input: CreateUserInput): Promise<User> {
    // âŒ Avoid this pattern
  }
}
```

#### Use Case Pattern with Functions

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });

    // Business logic
    const user = await userRepository.create(input);

    return { success: true, userId: user.id };
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;

// âŒ DON'T use class-based use cases
export class CreateUserProfileUseCase {
  constructor(
    private userRepository: UserRepository, // âŒ Avoid
    private logger: Logger // âŒ Avoid
  ) {}

  async execute(
    input: CreateUserProfileInput
  ): Promise<CreateUserProfileResult> {
    // âŒ Avoid this pattern
  }
}
```

### Benefits of Function-First Approach

1. **Immutability**: Functions promote immutable data patterns
2. **Testability**: Easy to mock dependencies and test pure functions
3. **Composability**: Functions can be easily composed and combined
4. **Type Safety**: Full TypeScript support without class complexity
5. **Performance**: No class instantiation overhead
6. **Simplicity**: Less boilerplate code and mental overhead

### Prettier Configuration

- Single quotes, semicolons, 120 char width
- 4 spaces indentation, trailing commas
- Format with: `npm run format`

## ğŸ—ï¸ SPECIFIC PATTERNS

### Database Layer

```typescript
// âœ… Database service pattern
export const getUserById =
  (db: AuroraClient): GetUserById =>
  async (id: number): Promise<User | null> => {
    const result = await db.select().from(user).where(eq(user.id, id));
    return result.length > 0 ? toUser(result[0]) : null;
  };
```

### API Handlers

```typescript
// âœ… API handler pattern with middleware
export const apiHandler = middy(handler)
  .use(requestLogger())
  .use(errorHandler())
  .use(parser({ schema: requestSchema }));
```

### Service Handlers

```typescript
// âœ… Service handler pattern
export const processUserRequest =
  (useCase: ProcessUserUseCase) => async (event: ServiceEvent) => {
    const { userId, action } = requestSchema.parse(event.data);
    const result = await useCase({ userId, action });
    return { success: true, data: result };
  };
```

## ğŸ“¦ CONFIGURATION MANAGEMENT

### Environment Configuration

- Use `src/config.ts` for centralized configuration
- Support environment variables with defaults
- Type all configuration with TypeScript interfaces

```typescript
// âœ… Configuration pattern
export const config = {
  aurora: {
    auroraSecretArn: process.env.AURORA_SECRET_ARN ?? '',
  },
  appSync: {
    endpoint: process.env.APPSYNC_ENDPOINT ?? '',
    awsRegion: process.env.AWS_REGION ?? 'us-west-2',
  },
} as const;
```

## ğŸš€ BUILD & DEPLOYMENT

### Build Configuration

- Use TypeScript compiler for building and deployment
- Build: `npm run build` (runs tsc build)
- Validate: `npm run validate`
- Deploy with infrastructure as code templates

### TypeScript Configuration

- Target: ES2022, Module: Preserve
- Strict mode enabled with all checks
- Path aliases configured in tsconfig.json
- No emit (handled by SAM)

## ğŸ”„ DEVELOPMENT WORKFLOW

### Essential Commands

- `npm run compile` - TypeScript compilation check
- `npm run test` - Run all unit tests
- `npm run test:integ` - Run integration tests
- `npm run test:e2e` - Run end-to-end tests
- `npm run test:eval` - Run AI evaluation tests
- `npm run lint` - ESLint check with auto-fix
- `npm run format` - Format code with Prettier
- `npm run build` - Build

### Database Operations

- `npm run db:generate` - Generate migrations
- `npm run db:migrate` - Run migrations
- `npm run db:drop` - Drop database (development)

### Git Workflow

- Use conventional commits: `feat:`, `fix:`, `docs:`, etc.
- Pre-commit hooks run format, lint, and tests

## ğŸ¯ ARCHITECTURE LAYERS

### Domain Layer

- **Entities**: Business objects with identity (using classes with behavior)
- **Value Objects**: Immutable values (using classes for complex objects, types for simple ones)
- **Events**: Domain events (using classes for rich domain events)
- **Errors**: Domain-specific exceptions (using classes extending Error)

#### When to Use Classes in Domain Layer

```typescript
// âœ… Use classes for domain entities with behavior
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string,
    public readonly createdAt: Date
  ) {}

  updateName(newName: string): User {
    if (!newName.trim()) {
      throw new InvalidUserNameError('Name cannot be empty');
    }
    return new User(this.id, this.email, newName, this.createdAt);
  }

  isActive(): boolean {
    const now = new Date();
    const monthsInactive =
      (now.getTime() - this.createdAt.getTime()) / (30 * 24 * 60 * 60 * 1000);
    return monthsInactive < 12;
  }
}

// âœ… Use classes for rich value objects
export class WorkoutTarget {
  constructor(
    public readonly type: 'power' | 'pace' | 'heartRate',
    public readonly value: number,
    public readonly unit: string
  ) {
    this.validate();
  }

  private validate(): void {
    if (this.value <= 0) {
      throw new InvalidWorkoutTargetError('Target value must be positive');
    }
  }

  equals(other: WorkoutTarget): boolean {
    return (
      this.type === other.type &&
      this.value === other.value &&
      this.unit === other.unit
    );
  }
}

// âœ… Use classes for domain errors
export class InvalidUserNameError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidUserNameError';
  }
}

// âœ… Use classes for domain events
export class UserCreatedEvent {
  constructor(
    public readonly userId: number,
    public readonly email: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

// âœ… Use types for simple value objects
export type UserStatus = 'active' | 'inactive' | 'suspended';

// âœ… Use interfaces for domain contracts
export interface UserRepository {
  save(user: User): Promise<void>;
  findById(id: number): Promise<User | null>;
}
```

### Application Layer

- **Use Cases**: Business logic orchestration
- **Services**: Application services for complex operations
- **Repository Interfaces**: Contracts for data access
- **Errors**: Application-specific exceptions

### Adapters Layer

- **Database**: Aurora/DynamoDB clients and services
- **API**: REST/HTTP handlers and middleware
- **AI**: AI service integrations
- **Messaging**: Message queue publishers and consumers
- **Workflow**: Workflow orchestration services
- **External APIs**: Third-party service clients

## ğŸ›¡ï¸ ERROR HANDLING

### Error Patterns

```typescript
// âœ… Domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// âœ… Use case error handling
try {
  const result = await useCase(input);
  return result;
} catch (error) {
  logger.error('Use case failed', { error, input });
  throw error;
}
```

## ğŸ”§ DEPENDENCY INJECTION & ARCHITECTURE PATTERNS

### Dependency Injection Pattern

This project uses **function-based dependency injection** where dependencies are injected as function parameters,
creating a clean separation between layers.

#### Application Layer (Use Cases)

Use cases are **factory functions** that receive their dependencies as parameters and return the actual use case
function:

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });
    const user = await userRepository.create(input);
    return { success: true, userId: user.id };
  };

// Export the type for dependency injection
export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

#### Application Services

Application services follow the same pattern and can depend on multiple repositories:

```typescript
// âœ… Application service factory pattern
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    if (!user) throw new UserNotFoundException(`User ${userId} not found`);

    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
    logger.info('Welcome email sent', { userId });
  },
});

export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;
```

#### Adapter Layer Implementation

Adapters implement the interfaces defined in the application layer:

```typescript
// âœ… Database adapter (implements UserRepository)
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },

  async findByEmail(email: string): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.email, email));
    return user ? toUser(user) : null;
  },
});

// âœ… External service adapter (implements EmailService)
export const createEmailService = (
  client: EmailClient,
  logger: Logger
): EmailService => ({
  async send(params: SendEmailParams): Promise<void> {
    try {
      await client.send(params);
      logger.info('Email sent successfully', { to: params.to });
    } catch (error) {
      logger.error('Failed to send email', { error, params });
      throw error;
    }
  },
});
```

#### Dependency Composition

Dependencies are composed at the application boundary (handlers, controllers):

```typescript
// âœ… Handler/Controller dependency composition
export const createUserHandler = (dependencies: {
  userRepository: UserRepository;
  emailService: EmailService;
  logger: Logger;
}) => {
  // Compose use cases with their dependencies
  const createUserUseCase = createUserProfile(
    dependencies.userRepository,
    dependencies.logger
  );

  const notificationService = userNotificationService(
    dependencies.userRepository,
    dependencies.emailService,
    dependencies.logger
  );

  return async (event: ApiEvent) => {
    const input = validateInput(event.body);
    const result = await createUserUseCase(input);

    // Side effects after main operation
    await notificationService.sendWelcomeEmail(result.userId);

    return { statusCode: 201, body: JSON.stringify(result) };
  };
};
```

#### Repository Interface Definition

Application layer defines contracts through TypeScript interfaces:

```typescript
// âœ… Repository interface (in application layer)
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  update(id: number, input: UpdateUserInput): Promise<User>;
  delete(id: number): Promise<void>;
}

// âœ… Service interface (in application layer)
export interface EmailService {
  send(params: SendEmailParams): Promise<void>;
  sendBatch(params: SendBatchEmailParams): Promise<void>;
}
```

#### Main Module Wiring

The main module (handler entry point) wires all dependencies together:

```typescript
// âœ… Main module dependency wiring
export const handler = async (event: ApiEvent) => {
  // Infrastructure setup
  const db = await createDatabaseClient();
  const emailClient = createEmailClient();
  const logger = createLogger();

  // Create adapters
  const userRepository = createUserRepository(db);
  const emailService = createEmailService(emailClient, logger);

  // Create handler with dependencies
  const userHandler = createUserHandler({
    userRepository,
    emailService,
    logger,
  });

  return await userHandler(event);
};
```

### Key Benefits of This Pattern

1. **Testability**: Easy to mock dependencies by passing test implementations
2. **Flexibility**: Can swap implementations without changing business logic
3. **Separation of Concerns**: Clean boundaries between layers
4. **Type Safety**: Full TypeScript support with interface contracts
5. **Composability**: Use cases can be composed into larger workflows

### Testing with Dependency Injection

```typescript
// âœ… Testing with mocked dependencies
describe('createUserProfile', () => {
  const mockUserRepository: UserRepository = {
    create: vi.fn(),
    findById: vi.fn(),
    findByEmail: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
  };

  const mockLogger: Logger = {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
  };

  it('should create user profile successfully', async () => {
    // Arrange
    const input = { name: 'John Doe', email: 'john@example.com' };
    const expectedUser = { id: 1, ...input };
    mockUserRepository.create.mockResolvedValue(expectedUser);

    const useCase = createUserProfile(mockUserRepository, mockLogger);

    // Act
    const result = await useCase(input);

    // Assert
    expect(result.success).toBe(true);
    expect(result.userId).toBe(1);
    expect(mockUserRepository.create).toHaveBeenCalledWith(input);
    expect(mockLogger.info).toHaveBeenCalledWith('Creating user profile', {
      input,
    });
  });
});
```

## ğŸ“Š MONITORING & LOGGING

### Logging Pattern

```typescript
// âœ… Structured logging
import { logger } from '@adapters/shared/logger';

logger.info('Operation started', { userId, companyId });
logger.error('Operation failed', { error, context });
```

### Tracing

- DataDog tracing enabled
- AWS X-Ray integration
- Performance monitoring for AI operations

## ğŸ”§ AI INTEGRATION

### AI Service Pattern

```typescript
// âœ… AI service integration
export const generateTopicContent =
  (aiClient: AiClient, logger: Logger) =>
  async (input: GenerateTopicContentInput): Promise<TopicContent> => {
    const prompt = buildPrompt(input);
    const response = await aiClient.generateText(prompt);
    return mapToTopicContent(response);
  };
```

## ğŸš« ANTI-PATTERNS TO AVOID

### Import & File System Anti-Patterns

- **Don't use relative imports** - Always use path aliases
- **Don't add .js extensions** to TypeScript imports
- **Don't use console.log** - Use structured logger
- **Don't hardcode configuration** - Use environment variables

### Function & Class Anti-Patterns

- **Don't use function declarations** - Use arrow functions
- **Don't use classes for services** - Use functions with dependency injection
- **Don't use classes for repositories** - Use factory functions
- **Don't use classes for use cases** - Use factory functions
- **Don't use class-based dependency injection** - Use function parameters
- **Don't use new keyword** - Except for domain entities and errors

### Architecture Anti-Patterns

- **Don't skip tests** - Maintain test coverage
- **Don't create circular dependencies** between layers
- **Don't mix business logic with infrastructure**
- **Don't use singletons** - Use dependency injection
- **Don't use static methods** - Use pure functions

### Examples of What to Avoid

```typescript
// âŒ DON'T use classes for application logic
export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(input: CreateUserInput): Promise<User> {
    return await this.userRepository.create(input);
  }
}

// âŒ DON'T use function declarations
function createUser(input: CreateUserInput): Promise<User> {
  // ...
}

// âŒ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {}

  async findById(id: number): Promise<User | null> {
    // ...
  }
}

// âŒ DON'T use singletons
export class Logger {
  private static instance: Logger;

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
}

// âŒ DON'T use static methods
export class UserHelpers {
  static validateEmail(email: string): boolean {
    // ...
  }
}

// âœ… DO use pure functions instead
export const validateEmail = (email: string): boolean => {
  // ...
};

// âœ… DO use function-based patterns
export const createUserService = (userRepository: UserRepository) => ({
  createUser: async (input: CreateUserInput): Promise<User> => {
    return await userRepository.create(input);
  },
});
```

## ğŸ¯ WHEN ADDING NEW FEATURES

1. **Start with domain**: Define entities, value objects, events
2. **Define use cases**: Create application layer logic
3. **Create adapters**: Implement infrastructure concerns
4. **Add resolvers/handlers**: Wire up API endpoints
5. **Write tests**: Unit, integration, and e2e tests
6. **Add evaluations**: For AI-related features
7. **Update documentation**: Keep schemas and docs current

## ğŸ“‹ SPECIFIC TECHNOLOGIES

### Database (Drizzle ORM)

```typescript
// âœ… Drizzle query pattern
const users = await db
  .select()
  .from(user)
  .where(and(eq(user.companyId, companyId), eq(user.isActive, true)));
```

### API Design

- Schema-first approach with code generation
- Typed handlers with input validation
- Real-time event processing support

### AI Services

- Centralized AI model instances
- Prompt engineering with evaluations
- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.
