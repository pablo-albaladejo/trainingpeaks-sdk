---
alwaysApply: true
---

# ğŸ—ï¸ TYPESCRIPT PROJECT

## ğŸ—ï¸ ARCHITECTURE DECISIONS

### Hexagonal Architecture (Clean Architecture)

- Use hexagonal architecture pattern for all modules
- Structure: domain/ â†’ application/ â†’ adapters/
- Domain layer: Pure business logic, entities, value objects, events
- Application layer: Use cases, services, repository interfaces
- Adapters layer: Infrastructure implementations (database, API clients, external services)

### ğŸš¨ **CRITICAL: Strict Ports & Adapters Separation Pattern**

**THIS IS THE MOST IMPORTANT RULE IN THIS PROJECT:**

The application layer MUST ONLY contain **contracts, types, and interfaces**.
The infrastructure layer MUST contain **all implementations**.

This enforces proper **Dependency Inversion Principle** and ensures true **hexagonal architecture**.

#### **ğŸ“‹ Application Layer: ONLY Definitions & Contracts**

### ğŸš¨ **CRITICAL: Individual Function Types Pattern**

**IMPORTANT RULE FOR APPLICATION SERVICES:**

All services in `src/application/services/` MUST use **individual function types** instead of grouped interface patterns.

This enforces **Interface Segregation Principle** and provides better composition flexibility.

#### **âœ… CORRECT: Individual Function Types**

```typescript
// âœ… CORRECT: src/application/services/user-validation.ts
// EXPORT INDIVIDUAL FUNCTION TYPES - NOT GROUPED INTERFACES

/**
 * Validates that a user ID meets business rules
 * @throws InvalidUserIdError if validation fails
 */
export type validateUserId = (userId: string) => void;

/**
 * Validates user email format and business rules
 * @throws InvalidEmailError if validation fails
 */
export type validateEmail = (email: string) => void;

/**
 * Validates filters for listing users
 * @throws InvalidFiltersError if validation fails
 */
export type validateListUsersFilters = (
  filters: UserValidationParams['filters']
) => void;

/**
 * Validates all business rules for user creation
 * @throws Various domain errors if validation fails
 */
export type validateUserCreationRules = (
  name: string,
  email: string,
  companyId: number,
  role: string
) => void;

/**
 * Validates that a user can be safely deleted
 * @throws InvalidUserDeletionError if deletion is not allowed
 */
export type validateUserCanBeDeleted = (user: User) => void;

/**
 * Factory function signature for creating user validation service
 * This defines the contract for how the service should be instantiated
 */
export type UserValidationServiceFactory = () => {
  validateUserId: validateUserId;
  validateEmail: validateEmail;
  validateListUsersFilters: validateListUsersFilters;
  validateUserCreationRules: validateUserCreationRules;
  validateUserCanBeDeleted: validateUserCanBeDeleted;
};
```

#### **âŒ INCORRECT: Grouped Interface Pattern**

```typescript
// âŒ WRONG: src/application/services/user-validation.ts
// DON'T USE GROUPED INTERFACES - USE INDIVIDUAL FUNCTION TYPES

/**
 * Contract for user validation operations
 * Defines what validation capabilities the system needs
 */
export type UserValidationService = {
  /**
   * Validates that a user ID meets business rules
   * @throws InvalidUserIdError if validation fails
   */
  validateUserId: (userId: string) => void;

  /**
   * Validates user email format and business rules
   * @throws InvalidEmailError if validation fails
   */
  validateEmail: (email: string) => void;

  /**
   * Validates filters for listing users
   * @throws InvalidFiltersError if validation fails
   */
  validateListUsersFilters: (filters: UserValidationParams['filters']) => void;

  /**
   * Validates all business rules for user creation
   * @throws Various domain errors if validation fails
   */
  validateUserCreationRules: (
    name: string,
    email: string,
    companyId: number,
    role: string
  ) => void;

  /**
   * Validates that a user can be safely deleted
   * @throws InvalidUserDeletionError if deletion is not allowed
   */
  validateUserCanBeDeleted: (user: User) => void;
};
```

#### **ğŸ¯ Benefits of Individual Function Types**

1. **Interface Segregation**: Each function is independently typed
2. **Better Composition**: Functions can be injected individually
3. **Testing Flexibility**: Mock individual functions easily
4. **Dependency Clarity**: Clear what each use case depends on
5. **Future Extensibility**: Easy to add/remove functions without breaking changes

```typescript
// âœ… CORRECT: src/application/services/user-validation.ts
// THIS FILE CONTAINS ONLY TYPE DEFINITIONS - NO IMPLEMENTATIONS

/**
 * User validation parameters for different validation scenarios
 */
export type UserValidationParams = {
  userId?: string;
  email?: string;
  name?: string;
  companyId?: number;
  role?: string;
  filters?: {
    startDate?: Date;
    endDate?: Date;
    status?: string;
    department?: string;
    limit?: number;
    offset?: number;
  };
  metadata?: {
    firstName?: string;
    lastName?: string;
    phone?: string;
    preferences?: Record<string, any>;
  };
};

/**
 * Contract for user validation operations
 * Defines what validation capabilities the system needs
 */
export type UserValidationService = {
  /**
   * Validates that a user ID meets business rules
   * @throws InvalidUserIdError if validation fails
   */
  validateUserId: (userId: string) => void;

  /**
   * Validates user email format and business rules
   * @throws InvalidEmailError if validation fails
   */
  validateEmail: (email: string) => void;

  /**
   * Validates filters for listing users
   * @throws InvalidFiltersError if validation fails
   */
  validateListUsersFilters: (filters: UserValidationParams['filters']) => void;

  /**
   * Validates all business rules for user creation
   * @throws Various domain errors if validation fails
   */
  validateUserCreationRules: (
    name: string,
    email: string,
    companyId: number,
    role: string
  ) => void;

  /**
   * Validates that a user can be safely deleted
   * @throws InvalidUserDeletionError if deletion is not allowed
   */
  validateUserCanBeDeleted: (user: User) => void;
};

/**
 * Factory function signature for creating user validation service
 * This defines the contract for how the service should be instantiated
 */
export type UserValidationServiceFactory = () => UserValidationService;
```

```typescript
// âœ… CORRECT: src/application/services/notification-publisher.ts
// EXAMPLE OF EVENT PUBLISHER - ONLY TYPE DEFINITIONS

type NotificationEvent = {
  eventId: string;
  notification: {
    id: number;
    type: string;
    title: string;
    message: string;
    recipientId: number;
    metadata: {
      priority: 'low' | 'medium' | 'high';
      category: string;
      actions?: Array<{
        label: string;
        action: string;
      }>;
    };
    createdAt: string;
    scheduledAt?: string;
  };
  context: {
    source: string;
    userId: number;
    timestamp: number;
  };
};

export type NotificationPublisherParams = {
  companyId: number;
  userId: number;
  sessionId: string;
  eventTimestamp: number;
  events: Array<NotificationEvent>;
};

/**
 * Contract for publishing notification events
 * This is a PORT - defines what the application needs
 */
export type NotificationPublisher = (
  params: NotificationPublisherParams
) => Promise<void>;
```

## ğŸš¨ **CRITICAL: Infrastructure Service Implementation Pattern**

**IMPORTANT RULE FOR INFRASTRUCTURE SERVICES:**

All implementations in `src/infrastructure/services/` MUST be factory functions that receive dependencies as parameters and return the exact implementation of the individual function type defined in `src/application/services/`.

### **ğŸš¨ CRITICAL: No Grouped Factory Functions - Export Individual Functions**

**MOST IMPORTANT ANTI-PATTERN TO AVOID:**

Infrastructure services must NEVER export factory functions that return grouped objects with multiple methods. Instead, they must export individual functions that implement individual application service types.

#### **âŒ ABSOLUTELY FORBIDDEN: Grouped Factory Functions**

```typescript
// âŒ WRONG: src/infrastructure/services/workout-validation.ts
// DON'T CREATE FACTORY FUNCTIONS THAT RETURN GROUPED OBJECTS

export const createWorkoutValidationService = (
  dependencies: SomeDependencies
) => ({
  validateWorkoutId: (workoutId: string): void => {
    // implementation
  },
  validateWorkoutFile: (fileData: WorkoutFile): void => {
    // implementation
  },
  validateListWorkoutsFilters: (filters: Filters): void => {
    // implementation
  },
  validateStructuredWorkoutBusinessRules: (structure: Structure): void => {
    // implementation
  },
  validateWorkoutCanBeDeleted: (workout: Workout): void => {
    // implementation
  },
});

// âŒ WRONG: This creates a grouped object instead of individual functions
export type WorkoutValidationService = ReturnType<
  typeof createWorkoutValidationService
>;
```

#### **âœ… CORRECT: Individual Function Exports**

```typescript
// âœ… CORRECT: src/infrastructure/services/workout-validation.ts
// EXPORT INDIVIDUAL FUNCTIONS THAT IMPLEMENT INDIVIDUAL TYPES

import type {
  ValidateWorkoutId,
  ValidateWorkoutFile,
  ValidateListWorkoutsFilters,
  ValidateStructuredWorkoutBusinessRules,
  ValidateWorkoutCanBeDeleted,
} from '@/application/services/workout-validation';

export const validateWorkoutId: ValidateWorkoutId = (
  workoutId: string
): void => {
  // implementation
};

export const validateWorkoutFile: ValidateWorkoutFile = (
  fileData: WorkoutFile
): void => {
  // implementation
};

export const validateListWorkoutsFilters: ValidateListWorkoutsFilters = (
  filters: Filters
): void => {
  // implementation
};

export const validateStructuredWorkoutBusinessRules: ValidateStructuredWorkoutBusinessRules =
  (structure: Structure, metadata?: Metadata): void => {
    // implementation
  };

export const validateWorkoutCanBeDeleted: ValidateWorkoutCanBeDeleted = (
  workout: Workout
): void => {
  // implementation
};
```

#### **ğŸ”§ For Functions That Need Dependencies**

```typescript
// âœ… CORRECT: src/application/services/workout-creation.ts
export type CreateStructuredWorkout = (
  request: CreateStructuredWorkoutRequest
) => Promise<CreateStructuredWorkoutResponse>;

// âœ… CORRECT: src/infrastructure/services/workout-creation.ts
export const createStructuredWorkout =
  (workoutRepository: WorkoutRepository): CreateStructuredWorkout =>
  async (
    request: CreateStructuredWorkoutRequest
  ): Promise<CreateStructuredWorkoutResponse> => {
    // implementation
  };
```

#### **ğŸ¯ Key Enforcement Rules**

1. **One Export Per Function Type**: Each infrastructure service file must export exactly one function per application service type
2. **Exact Type Implementation**: Each exported function must implement exactly one type from the application services
3. **No Grouped Objects**: Never return objects with multiple methods from factory functions
4. **Individual Dependencies**: If a function needs dependencies, it becomes a factory function that returns the implementation
5. **Direct Type Matching**: The infrastructure function signature must match the application type signature exactly

#### **ğŸ” How to Verify Compliance**

```typescript
// âœ… CORRECT Pattern Check:
// 1. Application service exports individual types
export type ValidateWorkoutId = (workoutId: string) => void;
export type ValidateWorkoutFile = (fileData: WorkoutFile) => void;

// 2. Infrastructure service exports individual functions implementing those types
export const validateWorkoutId: ValidateWorkoutId = (
  workoutId: string
): void => {
  /* */
};
export const validateWorkoutFile: ValidateWorkoutFile = (
  fileData: WorkoutFile
): void => {
  /* */
};

// âŒ WRONG Pattern Check:
// 1. Infrastructure service exports factory that returns grouped object
export const createValidationService = () => ({
  validateWorkoutId: (workoutId: string): void => {
    /* */
  },
  validateWorkoutFile: (fileData: WorkoutFile): void => {
    /* */
  },
});
```

#### **ğŸ“‹ Compliance Checklist**

- [ ] Each infrastructure service file exports individual functions, not factory functions that return grouped objects
- [ ] Each exported function implements exactly one application service type
- [ ] Function signatures match application service types exactly
- [ ] Dependencies are passed as parameters to factory functions when needed
- [ ] No `create*Service` patterns that return objects with multiple methods
- [ ] Each function can be imported and used independently

#### **ğŸš¨ Common Violations to Watch For**

1. **Grouped Factory Pattern**: `createSomeService()` returning `{ method1, method2, method3 }`
2. **Mixed Exports**: Exporting both individual functions and grouped factories
3. **Type Mismatches**: Infrastructure function signature doesn't match application type
4. **Unnecessary Grouping**: Creating objects when individual functions would work
5. **Service Class Pattern**: Using classes instead of functions in infrastructure

### **âœ… CORRECT: Infrastructure Factory Pattern**

```typescript
// âœ… CORRECT: src/application/services/card-event-publisher.ts
export type CardEventPublisher = (
  params: CardEventPublisherParams
) => Promise<void>;

// âœ… CORRECT: src/infrastructure/services/card-event-publisher.ts
export const cardEventPublisher =
  (appSyncEventPublisher: AppSyncEventPublisher): CardEventPublisher =>
  async (params): Promise<void> => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    await appSyncEventPublisher.publish(params);
  };
```

### **âŒ INCORRECT: Direct Function Export**

```typescript
// âŒ WRONG: src/infrastructure/services/card-event-publisher.ts
export const cardEventPublisher =
  (appSyncEventPublisher: AppSyncEventPublisher) =>
  async (params): Promise<void> => {
    // Missing return type annotation
  };
```

### **ğŸ¯ Key Points**

1. **Factory Functions**: Infrastructure functions are factory functions that receive dependencies
2. **Exact Implementation**: They return the exact implementation of the application service type
3. **Type Matching**: The return type MUST match the application service type exactly
4. **Naming Convention**: Function names in infrastructure use camelCase of the type name in application
5. **Dependency Injection**: Dependencies are passed as parameters, not through constructors

### **âœ… Real Examples from This Project**

```typescript
// âœ… CORRECT: src/application/services/workout-validation.ts
export type ValidateWorkoutData = (workoutData: WorkoutData) => void;

// âœ… CORRECT: src/infrastructure/services/workout-validation.ts
export const validateWorkoutData =
  (logger: Logger): ValidateWorkoutData =>
  (workoutData: WorkoutData): void => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    if (!workoutData.name || workoutData.name.trim() === '') {
      throw new WorkoutValidationError('Workout name is required');
    }

    if (!workoutData.structure || workoutData.structure.length === 0) {
      throw new WorkoutValidationError('Workout structure is required');
    }

    logger.info('Workout data validated successfully', {
      workoutId: workoutData.id,
    });
  };
```

```typescript
// âœ… CORRECT: src/application/services/auth-validation.ts
export type ValidateCredentials = (credentials: Credentials) => void;

// âœ… CORRECT: src/infrastructure/services/auth-validation.ts
export const validateCredentials =
  (logger: Logger): ValidateCredentials =>
  (credentials: Credentials): void => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    if (!credentials.username || credentials.username.trim() === '') {
      throw new AuthValidationError('Username is required');
    }

    if (!credentials.password || credentials.password.length < 8) {
      throw new AuthValidationError('Password must be at least 8 characters');
    }

    logger.info('Credentials validated successfully');
  };
```

#### **âš™ï¸ Infrastructure Layer: ONLY Implementations**

```typescript
// âœ… CORRECT: src/infrastructure/services/user-validation.ts
// THIS FILE CONTAINS THE ACTUAL IMPLEMENTATION

import type {
  UserValidationService,
  UserValidationServiceFactory,
} from '@/application/services/user-validation';
import {
  USER_LIMITS,
  EMAIL_CONFIG,
} from '@/application/services/user-constants';
import {
  InvalidUserIdError,
  InvalidEmailError,
  InvalidFiltersError,
  InvalidUserRoleError,
  InvalidUserDeletionError,
} from '@/domain/errors/user-errors';

/**
 * IMPLEMENTATION of UserValidationService
 * This is an ADAPTER - implements the port defined in application layer
 */
export const createUserValidationService: UserValidationServiceFactory =
  (): UserValidationService => ({
    validateUserId: (userId: string): void => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (userId === null || userId === undefined) {
        throw new InvalidUserIdError('User ID cannot be null or undefined');
      }

      if (typeof userId !== 'string') {
        throw new InvalidUserIdError('User ID must be a string');
      }

      if (!userId || userId.trim().length === 0) {
        throw new InvalidUserIdError('User ID is required');
      }

      if (userId.length > USER_LIMITS.ID_MAX_LENGTH) {
        throw new InvalidUserIdError(
          `User ID cannot exceed ${USER_LIMITS.ID_MAX_LENGTH} characters`
        );
      }
    },

    validateEmail: (email: string): void => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (email === null || email === undefined) {
        throw new InvalidEmailError('Email cannot be null or undefined');
      }

      if (typeof email !== 'string') {
        throw new InvalidEmailError('Email must be a string');
      }

      if (!email || email.trim().length === 0) {
        throw new InvalidEmailError('Email is required');
      }

      const emailRegex = EMAIL_CONFIG.VALIDATION_REGEX;
      if (!emailRegex.test(email)) {
        throw new InvalidEmailError('Invalid email format');
      }

      if (email.length > USER_LIMITS.EMAIL_MAX_LENGTH) {
        throw new InvalidEmailError(
          `Email cannot exceed ${USER_LIMITS.EMAIL_MAX_LENGTH} characters`
        );
      }
    },

    validateListUsersFilters: (filters) => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (filters === null || filters === undefined) {
        throw new InvalidFiltersError('Filters cannot be null or undefined');
      }

      if (typeof filters !== 'object') {
        throw new InvalidFiltersError('Filters must be an object');
      }

      // ... rest of implementation
    },

    validateUserCreationRules: (name, email, companyId, role) => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (name === null || name === undefined) {
        throw new InvalidUserRoleError('Name cannot be null or undefined');
      }

      if (email === null || email === undefined) {
        throw new InvalidEmailError('Email cannot be null or undefined');
      }

      // ... rest of implementation
    },

    validateUserCanBeDeleted: (user) => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (user === null || user === undefined) {
        throw new InvalidUserDeletionError('User cannot be null or undefined');
      }

      if (typeof user !== 'object') {
        throw new InvalidUserDeletionError('User must be an object');
      }

      // ... business rules implementation
    },
  });
```

```typescript
// âœ… CORRECT: src/infrastructure/services/notification-publisher.ts
// EXAMPLE OF EVENT PUBLISHER - ACTUAL IMPLEMENTATION

import type { NotificationPublisher } from '@/application/services/notification-publisher';
import type { EventPublisher } from '../event-publisher-client';

/**
 * IMPLEMENTATION of NotificationPublisher
 * This is an ADAPTER - implements the port defined in application layer
 */
export const notificationPublisher =
  (eventPublisher: EventPublisher): NotificationPublisher =>
  async (params): Promise<void> => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    if (params.events.length === 0) {
      return;
    }

    const publishableEvents = params.events.map((event) => {
      return {
        metadata: {
          source: 'notification-service',
          eventType: 'notification-created',
          eventId: event.eventId,
          eventTimestamp: new Date(params.eventTimestamp).toISOString(),
          userId: params.userId,
          companyId: params.companyId,
          sessionId: params.sessionId,
        },
        data: {
          notification: event.notification,
          context: event.context,
        },
      };
    });

    await eventPublisher.publish(
      publishableEvents,
      `/companies/${params.companyId}/users/${params.userId}/notifications`
    );
  };
```

#### **ğŸ”§ Dependency Injection at Infrastructure Boundary**

```typescript
// âœ… CORRECT: src/infrastructure/http/handlers/user-handler.ts
// DEPENDENCY INJECTION HAPPENS HERE - AT THE INFRASTRUCTURE BOUNDARY

import type { UserValidationService } from '@/application/services/user-validation';
import type { UserUtilityService } from '@/application/services/user-utility';
import type { UserRepository } from '@/application/ports/user';

// Import IMPLEMENTATIONS from infrastructure
import { createUserValidationService } from '@/infrastructure/services/user-validation';
import { createUserUtilityService } from '@/infrastructure/services/user-utility';
import { createUserRepository } from '@/infrastructure/repositories/user-repository';

export const createUserHandler = (dependencies: {
  database: DatabaseClient;
  logger: Logger;
}) => {
  // ğŸ”§ DEPENDENCY INJECTION - COMPOSE IMPLEMENTATIONS
  const userRepository: UserRepository = createUserRepository(
    dependencies.database
  );
  const validationService: UserValidationService =
    createUserValidationService();
  const utilityService: UserUtilityService = createUserUtilityService();

  // ğŸ¯ COMPOSE USE CASES WITH INJECTED DEPENDENCIES
  const createUserUseCase = createUserUseCase(
    userRepository,
    validationService,
    utilityService
  );

  return async (request: UserRequest) => {
    return await createUserUseCase(request.body);
  };
};
```

```typescript
// âœ… CORRECT: Following dependency injection pattern
// DEPENDENCY INJECTION IN USE CASE COMPOSITION

const notificationPublisher = createNotificationPublisher(
  createEventPublisher(httpClient, logger)
);

const useCase = createUserNotificationUseCase(notificationPublisher);
```

#### **ğŸ¯ Use Cases: Pure Orchestration**

```typescript
// âœ… CORRECT: src/application/use-cases/create-user.ts
// USE CASES ORCHESTRATE CONTRACTS - NO IMPLEMENTATIONS

import type { UserRepository } from '@/application/ports/user';
import type { UserValidationService } from '@/application/services/user-validation';
import type { UserUtilityService } from '@/application/services/user-utility';

/**
 * Use case for creating users
 * Uses CONTRACTS/PORTS - never direct implementations
 */
export const createUserUseCase =
  (
    userRepository: UserRepository, // â† PORT (contract)
    validationService: UserValidationService, // â† PORT (contract)
    utilityService: UserUtilityService // â† PORT (contract)
  ) =>
  async (input: CreateUserInput): Promise<CreateUserResponse> => {
    // ğŸ¯ ORCHESTRATE USING CONTRACTS ONLY

    // Use validation contract
    validationService.validateUserCreationRules(
      input.name,
      input.email,
      input.companyId,
      input.role
    );

    // Use utility contract
    const userId = utilityService.generateUserId();
    const hashedPassword = utilityService.hashPassword(input.password);

    // Use repository contract
    return await userRepository.createUser({
      ...input,
      id: userId,
      password: hashedPassword,
    });
  };
```

#### **ğŸ“ Strict Directory Structure**

```
src/
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ services/           # ğŸ“‹ ONLY TYPE DEFINITIONS & CONTRACTS
â”‚   â”‚   â”œâ”€â”€ user-validation.ts         # export type UserValidationService
â”‚   â”‚   â”œâ”€â”€ user-utility.ts            # export type UserUtilityService
â”‚   â”‚   â”œâ”€â”€ order-processing.ts        # export type OrderProcessingService
â”‚   â”‚   â”œâ”€â”€ notification-publisher.ts  # export type NotificationPublisher
â”‚   â”‚   â””â”€â”€ user-constants.ts          # export const LIMITS, DEFAULTS (configuration)
â”‚   â”œâ”€â”€ ports/              # ğŸ“‹ REPOSITORY & EXTERNAL CONTRACTS
â”‚   â”‚   â”œâ”€â”€ user.ts                    # export interface UserRepository
â”‚   â”‚   â”œâ”€â”€ order.ts                   # export interface OrderRepository
â”‚   â”‚   â””â”€â”€ auth.ts                    # export interface AuthRepository
â”‚   â””â”€â”€ use-cases/          # ğŸ¯ ORCHESTRATION USING CONTRACTS
â”‚       â”œâ”€â”€ create-user.ts
â”‚       â”œâ”€â”€ process-order.ts
â”‚       â””â”€â”€ send-notification.ts
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ services/           # âš™ï¸ ACTUAL IMPLEMENTATIONS OF APPLICATION/SERVICES
â”‚   â”‚   â”œâ”€â”€ user-validation.ts         # implements UserValidationService
â”‚   â”‚   â”œâ”€â”€ user-utility.ts            # implements UserUtilityService
â”‚   â”‚   â”œâ”€â”€ order-processing.ts        # implements OrderProcessingService
â”‚   â”‚   â””â”€â”€ notification-publisher.ts  # implements NotificationPublisher
â”‚   â”œâ”€â”€ repositories/       # ğŸ’¾ ACTUAL IMPLEMENTATIONS OF APPLICATION/PORTS
â”‚   â”‚   â”œâ”€â”€ user-repository.ts         # implements UserRepository
â”‚   â”‚   â”œâ”€â”€ order-repository.ts        # implements OrderRepository
â”‚   â”‚   â””â”€â”€ auth-repository.ts         # implements AuthRepository
â”‚   â””â”€â”€ http/              # ğŸŒ HANDLERS WITH DEPENDENCY INJECTION
â”‚       â”œâ”€â”€ user-handler.ts            # composes & injects implementations
â”‚       â””â”€â”€ order-handler.ts           # composes & injects implementations
â”‚
â””â”€â”€ domain/                # ğŸ¯ PURE BUSINESS LOGIC
    â”œâ”€â”€ entities/           # Classes with behavior
    â”œâ”€â”€ value-objects/      # Immutable values
    â””â”€â”€ errors/            # Domain-specific exceptions
```

#### **ğŸš¨ CRITICAL VIOLATIONS TO AVOID**

```typescript
// âŒ ABSOLUTELY FORBIDDEN: Implementation in application layer
// src/application/services/user-validation.ts

export const createUserValidationService = () => {
  // ğŸš« THIS IS WRONG - NO IMPLEMENTATIONS IN APPLICATION LAYER
  const validateUserId = (userId: string): void => {
    if (!userId) {
      throw new Error('Invalid ID'); // âŒ IMPLEMENTATION CODE
    }
  };

  return { validateUserId }; // âŒ RETURNING IMPLEMENTATION
};
```

```typescript
// âŒ ABSOLUTELY FORBIDDEN: Direct implementation imports in use cases
// src/application/use-cases/create-user.ts

import { createUserValidationService } from '@/application/services/user-validation'; // âŒ WRONG

export const createUserUseCase = (repository: UserRepository) => {
  const validation = createUserValidationService(); // âŒ DIRECT INSTANTIATION
  // ...
};
```

```typescript
// âŒ ABSOLUTELY FORBIDDEN: Mixed contracts and implementations
// src/application/services/user-service.ts

export type UserService = {
  createUser: (input: CreateUserInput) => Promise<User>;
};

// ğŸš« THIS VIOLATES SEPARATION - IMPLEMENTATION IN SAME FILE AS CONTRACT
export const createUserService = (repo: UserRepository): UserService => ({
  createUser: async (input) => {
    // âŒ IMPLEMENTATION CODE IN APPLICATION LAYER
    return await repo.create(input);
  },
});
```

#### **âœ… CORRECT PATTERNS SUMMARY**

| Layer                       | Contains                      | Examples                                                          | Purpose                                 |
| --------------------------- | ----------------------------- | ----------------------------------------------------------------- | --------------------------------------- |
| **Application/Services**    | Types, interfaces, contracts  | `export type ValidationService`, `export type EventPublisher`     | Define what the app needs (PORTS)       |
| **Infrastructure/Services** | Implementations, real logic   | `export const createValidationService = (): ValidationService =>` | Implement what the app needs (ADAPTERS) |
| **Application/Use-Cases**   | Orchestration using contracts | Function that receives contracts as params                        | Business logic orchestration            |
| **Infrastructure/HTTP**     | Dependency injection          | Create & inject implementations into use cases                    | Wire everything together                |

#### **ğŸ¯ Benefits of This Strict Separation**

1. **True Dependency Inversion**: High-level modules (use cases) don't depend on low-level modules (implementations)
2. **Perfect Testability**: Can easily mock any contract for testing
3. **Swappable Implementations**: Can have multiple implementations of same contract
4. **Clear Boundaries**: Impossible to accidentally mix layers
5. **Hexagonal Compliance**: True ports & adapters pattern
6. **ISP Compliance**: Interface Segregation - each contract is focused

#### **ğŸ§ª Testing with This Pattern**

```typescript
// âœ… PERFECT TESTABILITY - Mock contracts easily
describe('createUserUseCase', () => {
  const mockValidationService: UserValidationService = {
    validateUserId: vi.fn(),
    validateEmail: vi.fn(),
    validateListUsersFilters: vi.fn(),
    validateUserCreationRules: vi.fn(),
    validateUserCanBeDeleted: vi.fn(),
  };

  const mockUtilityService: UserUtilityService = {
    generateUserId: vi.fn(() => 'test-id'),
    hashPassword: vi.fn(() => 'hashed-password'),
    generateToken: vi.fn(() => 'test-token'),
    validatePermissions: vi.fn(),
  };

  const mockRepository: UserRepository = {
    createUser: vi.fn(),
    findById: vi.fn(),
    findByEmail: vi.fn(),
    updateUser: vi.fn(),
    deleteUser: vi.fn(),
  };

  it('should create user successfully', async () => {
    // Perfect isolation - using only contracts
    const useCase = createUserUseCase(
      mockRepository,
      mockValidationService,
      mockUtilityService
    );

    const result = await useCase(validInput);

    expect(mockValidationService.validateUserCreationRules).toHaveBeenCalled();
    expect(mockUtilityService.generateUserId).toHaveBeenCalled();
    expect(mockRepository.createUser).toHaveBeenCalled();
  });
});
```

### Function-First Philosophy

**CRITICAL**: This project follows a **function-first approach** where:

- **Classes are ONLY used for**:
  - Domain entities with behavior
  - Rich value objects with validation
  - Domain events
  - Domain errors extending Error
- **Functions are used for EVERYTHING else**:
  - Use cases (factory functions)
  - Application services (factory functions)
  - Repositories (factory functions)
  - Infrastructure adapters (factory functions)
  - Utilities and helpers (pure functions)

- **Dependency injection is function-based**:
  - Dependencies are passed as function parameters
  - No constructor injection or class-based DI
  - Services return objects with methods
  - Easy to test and compose

```typescript
// âœ… Correct pattern: Function-based use case
export const createUser =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserInput): Promise<User> => {
    // Implementation
  };

// âŒ Incorrect pattern: Class-based use case
export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {} // âŒ Avoid
}
```

### Directory Structure

```
project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domain/                   # Pure business logic
â”‚   â”‚   â”œâ”€â”€ models/               # Domain entities (with Zod validation)
â”‚   â”‚   â”œâ”€â”€ value-objects/        # Immutable value objects
â”‚   â”‚   â”œâ”€â”€ events/               # Domain events
â”‚   â”‚   â”œâ”€â”€ errors/               # Domain-specific errors
â”‚   â”‚   â””â”€â”€ ports/                # Interfaces (ports) for repositories and external services
â”‚   â”‚
â”‚   â”œâ”€â”€ application/              # Use cases and orchestration
â”‚   â”‚   â”œâ”€â”€ use-cases/            # Business use-case implementations
â”‚   â”‚   â”œâ”€â”€ dto/                  # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ services/             # Application services (orchestrators)
â”‚   â”‚   â””â”€â”€ ports/                # Interfaces required by use cases (driven ports)
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/           # Concrete adapters
â”‚   â”‚   â”œâ”€â”€ persistence/          # Database adapters (ORMs, driversâ€¦)
â”‚   â”‚   â”œâ”€â”€ messaging/            # Message-queue adapters
â”‚   â”‚   â”œâ”€â”€ external/             # Third-party service adapters (APIs, SDKsâ€¦)
â”‚   â”‚   â””â”€â”€ di/                   # Dependency-injection container setup
â”‚   â”‚
â”‚   â”œâ”€â”€ interfaces/               # Driven adapters (entry points)
â”‚   â”‚   â”œâ”€â”€ http/                 # HTTP controllers, routes, middleware
â”‚   â”‚   â”œâ”€â”€ cli/                  # CLI commands
â”‚   â”‚   â”œâ”€â”€ grpc/                 # gRPC handlers
â”‚   â”‚   â””â”€â”€ events/               # Event listeners (Kafka, RabbitMQâ€¦)
â”‚   â”‚
â”‚   â”œâ”€â”€ shared/                   # Cross-cutting utilities
â”‚   â”‚   â”œâ”€â”€ config/               # Env-var loading, config schemas
â”‚   â”‚   â”œâ”€â”€ logger/               # Central logger (e.g. Pino, Winston)
â”‚   â”‚   â””â”€â”€ utils/                # Generic helpers (date utils, transformersâ€¦)
â”‚   â”‚
â”‚   â”œâ”€â”€ config/                   # Project configs (ORM, ESLint, Jestâ€¦)
â”‚   â”‚   â”œâ”€â”€ ormconfig.ts
â”‚   â”‚   â”œâ”€â”€ logger.config.ts
â”‚   â”‚   â””â”€â”€ â€¦
â”‚   â”‚
â”‚   â”œâ”€â”€ __fixtures__/             # Test fixtures and builders
â”‚   â””â”€â”€ index.ts                  # Application entry point
â”‚
â”œâ”€â”€ tests/                        # Integration & end-to-end tests
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚   â””â”€â”€ evaluations/
â”‚
â”œâ”€â”€ docs/                         # Documentation (architecture diagrams, OpenAPIâ€¦)
â”‚
â”œâ”€â”€ scripts/                      # Utility scripts (migrations, seedersâ€¦)
â”‚
â”œâ”€â”€ .env                          # Default environment variables
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

## ğŸ’» CODE STYLE & CONVENTIONS

### File Naming

- Use kebab-case for all files in ./src
- Each module should have meaningful descriptive names
- Tests: place .test.ts files next to implementation files
- Integration tests: use .integ-test.ts suffix
- E2E tests: use .e2e-test.ts suffix

### TypeScript Imports

- **CRITICAL**: Always use path aliases (@/) instead of relative imports (../ or ./)
- **CRITICAL**: Never add .js extensions to TypeScript imports
- Use configured path aliases:
  - `@/*` - Root src directory
  - `@adapters/*` - Adapter implementations
  - `@application/*` - Application layer
  - `@domain/*` - Domain layer
  - `@evaluations/*` - Evaluation tests
  - `@fixtures/*` - Test fixtures
- TypeScript handles extensions automatically during transpilation

### Import Patterns

```typescript
// âœ… Correct imports (use path aliases)
import { User } from '@domain/entities/user';
import { createUserProfile } from '@application/use-cases/createUserProfile';
import { getAuroraClient } from '@adapters/database/clients/auroraClient';
import { logger } from '@adapters/shared/logger';
import { config } from '@/config';

// âŒ Incorrect imports (relative paths)
import { User } from '../domain/entities/user';
import { createUserProfile } from './use-cases/createUserProfile';
import { getAuroraClient } from '../../adapters/database/clients/auroraClient';
```

### Entity & Schema Patterns

```typescript
// âœ… Use Zod schemas for validation
import { z } from 'zod';

export const userSchema = z.object({
  id: z.number(),
  companyId: z.number(),
  name: z.string().max(64),
  email: z.string().email(),
  // ... other fields
});

export type User = z.infer<typeof userSchema>;
```

### Use Case Patterns

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

## ğŸ§ª TESTING STRATEGY

### Test Architecture

- **Unit tests**: `npm run test:unit` (fast, isolated)
- **Integration tests**: `npm run test:integ` (with real dependencies)
- **E2E tests**: `npm run test:e2e` (full system tests)
- **Evaluation tests**: `npm run test:eval` (AI model evaluations)
- Use Vitest as testing framework

### Test Patterns

```typescript
// âœ… Use builders for test data
import { userBuilder } from '@fixtures/user.fixture';
import { randomNumber } from '@fixtures/utils.fixture';

describe('createUserProfile', () => {
  it('should create user profile successfully', async () => {
    // Arrange
    const user = userBuilder.build();
    const companyId = randomNumber();

    // Act
    const result = await useCase({ userId: user.id, companyId });

    // Assert
    expect(result.isSuccess).toBe(true);
  });
});
```

### Test File Organization

- Unit tests: `*.test.ts` next to implementation
- Integration tests: `*.integ-test.ts` in same directory
- E2E tests: `*.e2e-test.ts` in same directory
- Use `__fixtures__/` for shared test data and builders

## ğŸ› ï¸ CODE QUALITY TOOLS

### ESLint Configuration

- Uses TypeScript ESLint with strict rules
- Enforces arrow functions over function declarations
- No console.log allowed (use logger instead)

### Key ESLint Rules

```typescript
// âœ… Correct patterns
const useCase = (dependencies) => async (input) => {
  /* ... */
};

logger.info('Message', { context });

// âŒ Avoid these patterns
function useCase() {
  /* ... */
} // Use arrow functions
console.log('message'); // Use logger instead
```

## ğŸ”„ FUNCTIONAL PROGRAMMING PATTERNS

### Function-First Architecture

This project follows a **function-first approach** where classes are avoided in favor of functions, dependency injection, and TypeScript types.

#### When to Use Classes vs Functions

```typescript
// âœ… Use classes ONLY for domain entities and value objects
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string
  ) {}

  updateName(newName: string): User {
    return new User(this.id, this.email, newName);
  }
}

// âœ… Use classes for domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// âœ… Use FUNCTIONS for everything else: use cases, services, repositories
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

// âœ… Use TYPES/INTERFACES for contracts
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
}

// âŒ DON'T use classes for services, repositories, or use cases
export class UserService {
  constructor(private userRepository: UserRepository) {} // âŒ Avoid

  async createUser(input: CreateUserInput): Promise<User> {
    // âŒ Avoid this pattern
  }
}
```

#### Functional Dependency Injection

```typescript
// âœ… Function-based dependency injection
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
  },

  sendPasswordReset: async (email: string) => {
    // Implementation
  },
});

// âœ… Export type for dependency injection
export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;

// âŒ DON'T use class-based dependency injection
export class UserNotificationService {
  constructor(
    private userRepository: UserRepository, // âŒ Avoid
    private emailService: EmailService, // âŒ Avoid
    private logger: Logger // âŒ Avoid
  ) {}
}
```

#### Repository Pattern with Functions

```typescript
// âœ… Function-based repository implementation
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },
});

// âŒ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {} // âŒ Avoid

  async create(input: CreateUserInput): Promise<User> {
    // âŒ Avoid this pattern
  }
}
```

#### Use Case Pattern with Functions

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });

    // Business logic
    const user = await userRepository.create(input);

    return { success: true, userId: user.id };
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;

// âŒ DON'T use class-based use cases
export class CreateUserProfileUseCase {
  constructor(
    private userRepository: UserRepository, // âŒ Avoid
    private logger: Logger // âŒ Avoid
  ) {}

  async execute(
    input: CreateUserProfileInput
  ): Promise<CreateUserProfileResult> {
    // âŒ Avoid this pattern
  }
}
```

### Benefits of Function-First Approach

1. **Immutability**: Functions promote immutable data patterns
2. **Testability**: Easy to mock dependencies and test pure functions
3. **Composability**: Functions can be easily composed and combined
4. **Type Safety**: Full TypeScript support without class complexity
5. **Performance**: No class instantiation overhead
6. **Simplicity**: Less boilerplate code and mental overhead

### Prettier Configuration

- Single quotes, semicolons, 120 char width
- 4 spaces indentation, trailing commas
- Format with: `npm run format`

## ğŸ—ï¸ SPECIFIC PATTERNS

### Database Layer

```typescript
// âœ… Database service pattern
export const getUserById =
  (db: AuroraClient): GetUserById =>
  async (id: number): Promise<User | null> => {
    const result = await db.select().from(user).where(eq(user.id, id));
    return result.length > 0 ? toUser(result[0]) : null;
  };
```

### API Handlers

```typescript
// âœ… API handler pattern with middleware
export const apiHandler = middy(handler)
  .use(requestLogger())
  .use(errorHandler())
  .use(parser({ schema: requestSchema }));
```

### Service Handlers

```typescript
// âœ… Service handler pattern
export const processUserRequest =
  (useCase: ProcessUserUseCase) => async (event: ServiceEvent) => {
    const { userId, action } = requestSchema.parse(event.data);
    const result = await useCase({ userId, action });
    return { success: true, data: result };
  };
```

## ğŸ“¦ CONFIGURATION MANAGEMENT

### Environment Configuration

- Use `src/config.ts` for centralized configuration
- Support environment variables with defaults
- Type all configuration with TypeScript interfaces

```typescript
// âœ… Configuration pattern
export const config = {
  aurora: {
    auroraSecretArn: process.env.AURORA_SECRET_ARN ?? '',
  },
  appSync: {
    endpoint: process.env.APPSYNC_ENDPOINT ?? '',
    awsRegion: process.env.AWS_REGION ?? 'us-west-2',
  },
} as const;
```

## ğŸš€ BUILD & DEPLOYMENT

### Build Configuration

- Use TypeScript compiler for building and deployment
- Build: `npm run build` (runs tsc build)
- Validate: `npm run validate`
- Deploy with infrastructure as code templates

### TypeScript Configuration

- Target: ES2022, Module: Preserve
- Strict mode enabled with all checks
- Path aliases configured in tsconfig.json
- No emit (handled by SAM)

## ğŸ”„ DEVELOPMENT WORKFLOW

### Essential Commands

- `npm run compile` - TypeScript compilation check
- `npm run test` - Run all unit tests
- `npm run test:integ` - Run integration tests
- `npm run test:e2e` - Run end-to-end tests
- `npm run test:eval` - Run AI evaluation tests
- `npm run lint` - ESLint check with auto-fix
- `npm run format` - Format code with Prettier
- `npm run build` - Build

### Database Operations

- `npm run db:generate` - Generate migrations
- `npm run db:migrate` - Run migrations
- `npm run db:drop` - Drop database (development)

### Git Workflow

- Use conventional commits: `feat:`, `fix:`, `docs:`, etc.
- Pre-commit hooks run format, lint, and tests

## ğŸ¯ ARCHITECTURE LAYERS

### Domain Layer

- **Entities**: Business objects with identity (using classes with behavior)
- **Value Objects**: Immutable values (using classes for complex objects, types for simple ones)
- **Events**: Domain events (using classes for rich domain events)
- **Errors**: Domain-specific exceptions (using classes extending Error)

#### When to Use Classes in Domain Layer

```typescript
// âœ… Use classes for domain entities with behavior
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string,
    public readonly createdAt: Date
  ) {}

  updateName(newName: string): User {
    if (!newName.trim()) {
      throw new InvalidUserNameError('Name cannot be empty');
    }
    return new User(this.id, this.email, newName, this.createdAt);
  }

  isActive(): boolean {
    const now = new Date();
    const monthsInactive =
      (now.getTime() - this.createdAt.getTime()) / (30 * 24 * 60 * 60 * 1000);
    return monthsInactive < 12;
  }
}

// âœ… Use classes for rich value objects
export class WorkoutTarget {
  constructor(
    public readonly type: 'power' | 'pace' | 'heartRate',
    public readonly value: number,
    public readonly unit: string
  ) {
    this.validate();
  }

  private validate(): void {
    if (this.value <= 0) {
      throw new InvalidWorkoutTargetError('Target value must be positive');
    }
  }

  equals(other: WorkoutTarget): boolean {
    return (
      this.type === other.type &&
      this.value === other.value &&
      this.unit === other.unit
    );
  }
}

// âœ… Use classes for domain errors
export class InvalidUserNameError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidUserNameError';
  }
}

// âœ… Use classes for domain events
export class UserCreatedEvent {
  constructor(
    public readonly userId: number,
    public readonly email: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

// âœ… Use types for simple value objects
export type UserStatus = 'active' | 'inactive' | 'suspended';

// âœ… Use interfaces for domain contracts
export interface UserRepository {
  save(user: User): Promise<void>;
  findById(id: number): Promise<User | null>;
}
```

### Application Layer

- **Use Cases**: Business logic orchestration
- **Services**: Application services for complex operations
- **Repository Interfaces**: Contracts for data access
- **Errors**: Application-specific exceptions

### Adapters Layer

- **Database**: Aurora/DynamoDB clients and services
- **API**: REST/HTTP handlers and middleware
- **AI**: AI service integrations
- **Messaging**: Message queue publishers and consumers
- **Workflow**: Workflow orchestration services
- **External APIs**: Third-party service clients

## ğŸ›¡ï¸ ERROR HANDLING

### Error Patterns

```typescript
// âœ… Domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// âœ… Use case error handling
try {
  const result = await useCase(input);
  return result;
} catch (error) {
  logger.error('Use case failed', { error, input });
  throw error;
}
```

## ğŸ”§ DEPENDENCY INJECTION & ARCHITECTURE PATTERNS

### Dependency Injection Pattern

This project uses **function-based dependency injection** where dependencies are injected as function parameters,
creating a clean separation between layers.

#### Application Layer (Use Cases)

Use cases are **factory functions** that receive their dependencies as parameters and return the actual use case
function:

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });
    const user = await userRepository.create(input);
    return { success: true, userId: user.id };
  };

// Export the type for dependency injection
export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

#### Application Services

Application services follow the same pattern and can depend on multiple repositories:

```typescript
// âœ… Application service factory pattern
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    if (!user) throw new UserNotFoundException(`User ${userId} not found`);

    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
    logger.info('Welcome email sent', { userId });
  },
});

export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;
```

#### Adapter Layer Implementation

Adapters implement the interfaces defined in the application layer:

```typescript
// âœ… Database adapter (implements UserRepository)
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },

  async findByEmail(email: string): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.email, email));
    return user ? toUser(user) : null;
  },
});

// âœ… External service adapter (implements EmailService)
export const createEmailService = (
  client: EmailClient,
  logger: Logger
): EmailService => ({
  async send(params: SendEmailParams): Promise<void> {
    try {
      await client.send(params);
      logger.info('Email sent successfully', { to: params.to });
    } catch (error) {
      logger.error('Failed to send email', { error, params });
      throw error;
    }
  },
});
```

#### Dependency Composition

Dependencies are composed at the application boundary (handlers, controllers):

```typescript
// âœ… Handler/Controller dependency composition
export const createUserHandler = (dependencies: {
  userRepository: UserRepository;
  emailService: EmailService;
  logger: Logger;
}) => {
  // Compose use cases with their dependencies
  const createUserUseCase = createUserProfile(
    dependencies.userRepository,
    dependencies.logger
  );

  const notificationService = userNotificationService(
    dependencies.userRepository,
    dependencies.emailService,
    dependencies.logger
  );

  return async (event: ApiEvent) => {
    const input = validateInput(event.body);
    const result = await createUserUseCase(input);

    // Side effects after main operation
    await notificationService.sendWelcomeEmail(result.userId);

    return { statusCode: 201, body: JSON.stringify(result) };
  };
};
```

#### Repository Interface Definition

Application layer defines contracts through TypeScript interfaces:

```typescript
// âœ… Repository interface (in application layer)
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  update(id: number, input: UpdateUserInput): Promise<User>;
  delete(id: number): Promise<void>;
}

// âœ… Service interface (in application layer)
export interface EmailService {
  send(params: SendEmailParams): Promise<void>;
  sendBatch(params: SendBatchEmailParams): Promise<void>;
}
```

#### Main Module Wiring

The main module (handler entry point) wires all dependencies together:

```typescript
// âœ… Main module dependency wiring
export const handler = async (event: ApiEvent) => {
  // Infrastructure setup
  const db = await createDatabaseClient();
  const emailClient = createEmailClient();
  const logger = createLogger();

  // Create adapters
  const userRepository = createUserRepository(db);
  const emailService = createEmailService(emailClient, logger);

  // Create handler with dependencies
  const userHandler = createUserHandler({
    userRepository,
    emailService,
    logger,
  });

  return await userHandler(event);
};
```

### Key Benefits of This Pattern

1. **Testability**: Easy to mock dependencies by passing test implementations
2. **Flexibility**: Can swap implementations without changing business logic
3. **Separation of Concerns**: Clean boundaries between layers
4. **Type Safety**: Full TypeScript support with interface contracts
5. **Composability**: Use cases can be composed into larger workflows

### Testing with Dependency Injection

```typescript
// âœ… Testing with mocked dependencies
describe('createUserProfile', () => {
  const mockUserRepository: UserRepository = {
    create: vi.fn(),
    findById: vi.fn(),
    findByEmail: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
  };

  const mockLogger: Logger = {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
  };

  it('should create user profile successfully', async () => {
    // Arrange
    const input = { name: 'John Doe', email: 'john@example.com' };
    const expectedUser = { id: 1, ...input };
    mockUserRepository.create.mockResolvedValue(expectedUser);

    const useCase = createUserProfile(mockUserRepository, mockLogger);

    // Act
    const result = await useCase(input);

    // Assert
    expect(result.success).toBe(true);
    expect(result.userId).toBe(1);
    expect(mockUserRepository.create).toHaveBeenCalledWith(input);
    expect(mockLogger.info).toHaveBeenCalledWith('Creating user profile', {
      input,
    });
  });
});
```

## ğŸ“Š MONITORING & LOGGING

### Logging Pattern

```typescript
// âœ… Structured logging
import { logger } from '@adapters/shared/logger';

logger.info('Operation started', { userId, companyId });
logger.error('Operation failed', { error, context });
```

### Tracing

- DataDog tracing enabled
- AWS X-Ray integration
- Performance monitoring for AI operations

## ğŸ”§ AI INTEGRATION

### AI Service Pattern

```typescript
// âœ… AI service integration
export const generateTopicContent =
  (aiClient: AiClient, logger: Logger) =>
  async (input: GenerateTopicContentInput): Promise<TopicContent> => {
    const prompt = buildPrompt(input);
    const response = await aiClient.generateText(prompt);
    return mapToTopicContent(response);
  };
```

## ğŸš« ANTI-PATTERNS TO AVOID

### Import & File System Anti-Patterns

- **Don't use relative imports** - Always use path aliases
- **Don't add .js extensions** to TypeScript imports
- **Don't use console.log** - Use structured logger
- **Don't hardcode configuration** - Use environment variables

### Function & Class Anti-Patterns

- **Don't use function declarations** - Use arrow functions
- **Don't use classes for services** - Use functions with dependency injection
- **Don't use classes for repositories** - Use factory functions
- **Don't use classes for use cases** - Use factory functions
- **Don't use class-based dependency injection** - Use function parameters
- **Don't use new keyword** - Except for domain entities and errors

### Architecture Anti-Patterns

- **Don't skip tests** - Maintain test coverage
- **Don't create circular dependencies** between layers
- **Don't mix business logic with infrastructure**
- **Don't use singletons** - Use dependency injection
- **Don't use static methods** - Use pure functions

### Examples of What to Avoid

```typescript
// âŒ DON'T use classes for application logic
export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(input: CreateUserInput): Promise<User> {
    return await this.userRepository.create(input);
  }
}

// âŒ DON'T use function declarations
function createUser(input: CreateUserInput): Promise<User> {
  // ...
}

// âŒ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {}

  async findById(id: number): Promise<User | null> {
    // ...
  }
}

// âŒ DON'T use singletons
export class Logger {
  private static instance: Logger;

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
}

// âŒ DON'T use static methods
export class UserHelpers {
  static validateEmail(email: string): boolean {
    // ...
  }
}

// âœ… DO use pure functions instead
export const validateEmail = (email: string): boolean => {
  // ...
};

// âœ… DO use function-based patterns
export const createUserService = (userRepository: UserRepository) => ({
  createUser: async (input: CreateUserInput): Promise<User> => {
    return await userRepository.create(input);
  },
});
```

## ğŸ¯ WHEN ADDING NEW FEATURES

1. **Start with domain**: Define entities, value objects, events
2. **Define use cases**: Create application layer logic
3. **Create adapters**: Implement infrastructure concerns
4. **Add resolvers/handlers**: Wire up API endpoints
5. **Write tests**: Unit, integration, and e2e tests
6. **Add evaluations**: For AI-related features
7. **Update documentation**: Keep schemas and docs current

## ğŸ“‹ SPECIFIC TECHNOLOGIES

### Database (Drizzle ORM)

```typescript
// âœ… Drizzle query pattern
const users = await db
  .select()
  .from(user)
  .where(and(eq(user.companyId, companyId), eq(user.isActive, true)));
```

### API Design

- Schema-first approach with code generation
- Typed handlers with input validation
- Real-time event processing support

### AI Services

- Centralized AI model instances
- Prompt engineering with evaluations
- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.

- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.

- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.

- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.

# ğŸ—ï¸ TYPESCRIPT PROJECT

## ğŸ—ï¸ ARCHITECTURE DECISIONS

### Hexagonal Architecture (Clean Architecture)

- Use hexagonal architecture pattern for all modules
- Structure: domain/ â†’ application/ â†’ adapters/
- Domain layer: Pure business logic, entities, value objects, events
- Application layer: Use cases, services, repository interfaces
- Adapters layer: Infrastructure implementations (database, API clients, external services)

### ğŸš¨ **CRITICAL: Strict Ports & Adapters Separation Pattern**

**THIS IS THE MOST IMPORTANT RULE IN THIS PROJECT:**

The application layer MUST ONLY contain **contracts, types, and interfaces**.
The infrastructure layer MUST contain **all implementations**.

This enforces proper **Dependency Inversion Principle** and ensures true **hexagonal architecture**.

#### **ğŸ“‹ Application Layer: ONLY Definitions & Contracts**

### ğŸš¨ **CRITICAL: Individual Function Types Pattern**

**IMPORTANT RULE FOR APPLICATION SERVICES:**

All services in `src/application/services/` MUST use **individual function types** instead of grouped interface patterns.

This enforces **Interface Segregation Principle** and provides better composition flexibility.

#### **âœ… CORRECT: Individual Function Types**

```typescript
// âœ… CORRECT: src/application/services/user-validation.ts
// EXPORT INDIVIDUAL FUNCTION TYPES - NOT GROUPED INTERFACES

/**
 * Validates that a user ID meets business rules
 * @throws InvalidUserIdError if validation fails
 */
export type validateUserId = (userId: string) => void;

/**
 * Validates user email format and business rules
 * @throws InvalidEmailError if validation fails
 */
export type validateEmail = (email: string) => void;

/**
 * Validates filters for listing users
 * @throws InvalidFiltersError if validation fails
 */
export type validateListUsersFilters = (
  filters: UserValidationParams['filters']
) => void;

/**
 * Validates all business rules for user creation
 * @throws Various domain errors if validation fails
 */
export type validateUserCreationRules = (
  name: string,
  email: string,
  companyId: number,
  role: string
) => void;

/**
 * Validates that a user can be safely deleted
 * @throws InvalidUserDeletionError if deletion is not allowed
 */
export type validateUserCanBeDeleted = (user: User) => void;

/**
 * Factory function signature for creating user validation service
 * This defines the contract for how the service should be instantiated
 */
export type UserValidationServiceFactory = () => {
  validateUserId: validateUserId;
  validateEmail: validateEmail;
  validateListUsersFilters: validateListUsersFilters;
  validateUserCreationRules: validateUserCreationRules;
  validateUserCanBeDeleted: validateUserCanBeDeleted;
};
```

#### **âŒ INCORRECT: Grouped Interface Pattern**

```typescript
// âŒ WRONG: src/application/services/user-validation.ts
// DON'T USE GROUPED INTERFACES - USE INDIVIDUAL FUNCTION TYPES

/**
 * Contract for user validation operations
 * Defines what validation capabilities the system needs
 */
export type UserValidationService = {
  /**
   * Validates that a user ID meets business rules
   * @throws InvalidUserIdError if validation fails
   */
  validateUserId: (userId: string) => void;

  /**
   * Validates user email format and business rules
   * @throws InvalidEmailError if validation fails
   */
  validateEmail: (email: string) => void;

  /**
   * Validates filters for listing users
   * @throws InvalidFiltersError if validation fails
   */
  validateListUsersFilters: (filters: UserValidationParams['filters']) => void;

  /**
   * Validates all business rules for user creation
   * @throws Various domain errors if validation fails
   */
  validateUserCreationRules: (
    name: string,
    email: string,
    companyId: number,
    role: string
  ) => void;

  /**
   * Validates that a user can be safely deleted
   * @throws InvalidUserDeletionError if deletion is not allowed
   */
  validateUserCanBeDeleted: (user: User) => void;
};
```

#### **ğŸ¯ Benefits of Individual Function Types**

1. **Interface Segregation**: Each function is independently typed
2. **Better Composition**: Functions can be injected individually
3. **Testing Flexibility**: Mock individual functions easily
4. **Dependency Clarity**: Clear what each use case depends on
5. **Future Extensibility**: Easy to add/remove functions without breaking changes

```typescript
// âœ… CORRECT: src/application/services/user-validation.ts
// THIS FILE CONTAINS ONLY TYPE DEFINITIONS - NO IMPLEMENTATIONS

/**
 * User validation parameters for different validation scenarios
 */
export type UserValidationParams = {
  userId?: string;
  email?: string;
  name?: string;
  companyId?: number;
  role?: string;
  filters?: {
    startDate?: Date;
    endDate?: Date;
    status?: string;
    department?: string;
    limit?: number;
    offset?: number;
  };
  metadata?: {
    firstName?: string;
    lastName?: string;
    phone?: string;
    preferences?: Record<string, any>;
  };
};

/**
 * Contract for user validation operations
 * Defines what validation capabilities the system needs
 */
export type UserValidationService = {
  /**
   * Validates that a user ID meets business rules
   * @throws InvalidUserIdError if validation fails
   */
  validateUserId: (userId: string) => void;

  /**
   * Validates user email format and business rules
   * @throws InvalidEmailError if validation fails
   */
  validateEmail: (email: string) => void;

  /**
   * Validates filters for listing users
   * @throws InvalidFiltersError if validation fails
   */
  validateListUsersFilters: (filters: UserValidationParams['filters']) => void;

  /**
   * Validates all business rules for user creation
   * @throws Various domain errors if validation fails
   */
  validateUserCreationRules: (
    name: string,
    email: string,
    companyId: number,
    role: string
  ) => void;

  /**
   * Validates that a user can be safely deleted
   * @throws InvalidUserDeletionError if deletion is not allowed
   */
  validateUserCanBeDeleted: (user: User) => void;
};

/**
 * Factory function signature for creating user validation service
 * This defines the contract for how the service should be instantiated
 */
export type UserValidationServiceFactory = () => UserValidationService;
```

```typescript
// âœ… CORRECT: src/application/services/notification-publisher.ts
// EXAMPLE OF EVENT PUBLISHER - ONLY TYPE DEFINITIONS

type NotificationEvent = {
  eventId: string;
  notification: {
    id: number;
    type: string;
    title: string;
    message: string;
    recipientId: number;
    metadata: {
      priority: 'low' | 'medium' | 'high';
      category: string;
      actions?: Array<{
        label: string;
        action: string;
      }>;
    };
    createdAt: string;
    scheduledAt?: string;
  };
  context: {
    source: string;
    userId: number;
    timestamp: number;
  };
};

export type NotificationPublisherParams = {
  companyId: number;
  userId: number;
  sessionId: string;
  eventTimestamp: number;
  events: Array<NotificationEvent>;
};

/**
 * Contract for publishing notification events
 * This is a PORT - defines what the application needs
 */
export type NotificationPublisher = (
  params: NotificationPublisherParams
) => Promise<void>;
```

## ğŸš¨ **CRITICAL: Infrastructure Service Implementation Pattern**

**IMPORTANT RULE FOR INFRASTRUCTURE SERVICES:**

All implementations in `src/infrastructure/services/` MUST be factory functions that receive dependencies as parameters and return the exact implementation of the individual function type defined in `src/application/services/`.

### **ğŸš¨ CRITICAL: No Grouped Factory Functions - Export Individual Functions**

**MOST IMPORTANT ANTI-PATTERN TO AVOID:**

Infrastructure services must NEVER export factory functions that return grouped objects with multiple methods. Instead, they must export individual functions that implement individual application service types.

#### **âŒ ABSOLUTELY FORBIDDEN: Grouped Factory Functions**

```typescript
// âŒ WRONG: src/infrastructure/services/workout-validation.ts
// DON'T CREATE FACTORY FUNCTIONS THAT RETURN GROUPED OBJECTS

export const createWorkoutValidationService = (
  dependencies: SomeDependencies
) => ({
  validateWorkoutId: (workoutId: string): void => {
    // implementation
  },
  validateWorkoutFile: (fileData: WorkoutFile): void => {
    // implementation
  },
  validateListWorkoutsFilters: (filters: Filters): void => {
    // implementation
  },
  validateStructuredWorkoutBusinessRules: (structure: Structure): void => {
    // implementation
  },
  validateWorkoutCanBeDeleted: (workout: Workout): void => {
    // implementation
  },
});

// âŒ WRONG: This creates a grouped object instead of individual functions
export type WorkoutValidationService = ReturnType<
  typeof createWorkoutValidationService
>;
```

#### **âœ… CORRECT: Individual Function Exports**

```typescript
// âœ… CORRECT: src/infrastructure/services/workout-validation.ts
// EXPORT INDIVIDUAL FUNCTIONS THAT IMPLEMENT INDIVIDUAL TYPES

import type {
  ValidateWorkoutId,
  ValidateWorkoutFile,
  ValidateListWorkoutsFilters,
  ValidateStructuredWorkoutBusinessRules,
  ValidateWorkoutCanBeDeleted,
} from '@/application/services/workout-validation';

export const validateWorkoutId: ValidateWorkoutId = (
  workoutId: string
): void => {
  // implementation
};

export const validateWorkoutFile: ValidateWorkoutFile = (
  fileData: WorkoutFile
): void => {
  // implementation
};

export const validateListWorkoutsFilters: ValidateListWorkoutsFilters = (
  filters: Filters
): void => {
  // implementation
};

export const validateStructuredWorkoutBusinessRules: ValidateStructuredWorkoutBusinessRules =
  (structure: Structure, metadata?: Metadata): void => {
    // implementation
  };

export const validateWorkoutCanBeDeleted: ValidateWorkoutCanBeDeleted = (
  workout: Workout
): void => {
  // implementation
};
```

#### **ğŸ”§ For Functions That Need Dependencies**

```typescript
// âœ… CORRECT: src/application/services/workout-creation.ts
export type CreateStructuredWorkout = (
  request: CreateStructuredWorkoutRequest
) => Promise<CreateStructuredWorkoutResponse>;

// âœ… CORRECT: src/infrastructure/services/workout-creation.ts
export const createStructuredWorkout =
  (workoutRepository: WorkoutRepository): CreateStructuredWorkout =>
  async (
    request: CreateStructuredWorkoutRequest
  ): Promise<CreateStructuredWorkoutResponse> => {
    // implementation
  };
```

#### **ğŸ¯ Key Enforcement Rules**

1. **One Export Per Function Type**: Each infrastructure service file must export exactly one function per application service type
2. **Exact Type Implementation**: Each exported function must implement exactly one type from the application services
3. **No Grouped Objects**: Never return objects with multiple methods from factory functions
4. **Individual Dependencies**: If a function needs dependencies, it becomes a factory function that returns the implementation
5. **Direct Type Matching**: The infrastructure function signature must match the application type signature exactly

#### **ğŸ” How to Verify Compliance**

```typescript
// âœ… CORRECT Pattern Check:
// 1. Application service exports individual types
export type ValidateWorkoutId = (workoutId: string) => void;
export type ValidateWorkoutFile = (fileData: WorkoutFile) => void;

// 2. Infrastructure service exports individual functions implementing those types
export const validateWorkoutId: ValidateWorkoutId = (
  workoutId: string
): void => {
  /* */
};
export const validateWorkoutFile: ValidateWorkoutFile = (
  fileData: WorkoutFile
): void => {
  /* */
};

// âŒ WRONG Pattern Check:
// 1. Infrastructure service exports factory that returns grouped object
export const createValidationService = () => ({
  validateWorkoutId: (workoutId: string): void => {
    /* */
  },
  validateWorkoutFile: (fileData: WorkoutFile): void => {
    /* */
  },
});
```

#### **ğŸ“‹ Compliance Checklist**

- [ ] Each infrastructure service file exports individual functions, not factory functions that return grouped objects
- [ ] Each exported function implements exactly one application service type
- [ ] Function signatures match application service types exactly
- [ ] Dependencies are passed as parameters to factory functions when needed
- [ ] No `create*Service` patterns that return objects with multiple methods
- [ ] Each function can be imported and used independently

#### **ğŸš¨ Common Violations to Watch For**

1. **Grouped Factory Pattern**: `createSomeService()` returning `{ method1, method2, method3 }`
2. **Mixed Exports**: Exporting both individual functions and grouped factories
3. **Type Mismatches**: Infrastructure function signature doesn't match application type
4. **Unnecessary Grouping**: Creating objects when individual functions would work
5. **Service Class Pattern**: Using classes instead of functions in infrastructure

### **âœ… CORRECT: Infrastructure Factory Pattern**

```typescript
// âœ… CORRECT: src/application/services/card-event-publisher.ts
export type CardEventPublisher = (
  params: CardEventPublisherParams
) => Promise<void>;

// âœ… CORRECT: src/infrastructure/services/card-event-publisher.ts
export const cardEventPublisher =
  (appSyncEventPublisher: AppSyncEventPublisher): CardEventPublisher =>
  async (params): Promise<void> => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    await appSyncEventPublisher.publish(params);
  };
```

### **âŒ INCORRECT: Direct Function Export**

```typescript
// âŒ WRONG: src/infrastructure/services/card-event-publisher.ts
export const cardEventPublisher =
  (appSyncEventPublisher: AppSyncEventPublisher) =>
  async (params): Promise<void> => {
    // Missing return type annotation
  };
```

### **ğŸ¯ Key Points**

1. **Factory Functions**: Infrastructure functions are factory functions that receive dependencies
2. **Exact Implementation**: They return the exact implementation of the application service type
3. **Type Matching**: The return type MUST match the application service type exactly
4. **Naming Convention**: Function names in infrastructure use camelCase of the type name in application
5. **Dependency Injection**: Dependencies are passed as parameters, not through constructors

### **âœ… Real Examples from This Project**

```typescript
// âœ… CORRECT: src/application/services/workout-validation.ts
export type ValidateWorkoutData = (workoutData: WorkoutData) => void;

// âœ… CORRECT: src/infrastructure/services/workout-validation.ts
export const validateWorkoutData =
  (logger: Logger): ValidateWorkoutData =>
  (workoutData: WorkoutData): void => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    if (!workoutData.name || workoutData.name.trim() === '') {
      throw new WorkoutValidationError('Workout name is required');
    }

    if (!workoutData.structure || workoutData.structure.length === 0) {
      throw new WorkoutValidationError('Workout structure is required');
    }

    logger.info('Workout data validated successfully', {
      workoutId: workoutData.id,
    });
  };
```

```typescript
// âœ… CORRECT: src/application/services/auth-validation.ts
export type ValidateCredentials = (credentials: Credentials) => void;

// âœ… CORRECT: src/infrastructure/services/auth-validation.ts
export const validateCredentials =
  (logger: Logger): ValidateCredentials =>
  (credentials: Credentials): void => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    if (!credentials.username || credentials.username.trim() === '') {
      throw new AuthValidationError('Username is required');
    }

    if (!credentials.password || credentials.password.length < 8) {
      throw new AuthValidationError('Password must be at least 8 characters');
    }

    logger.info('Credentials validated successfully');
  };
```

#### **âš™ï¸ Infrastructure Layer: ONLY Implementations**

```typescript
// âœ… CORRECT: src/infrastructure/services/user-validation.ts
// THIS FILE CONTAINS THE ACTUAL IMPLEMENTATION

import type {
  UserValidationService,
  UserValidationServiceFactory,
} from '@/application/services/user-validation';
import {
  USER_LIMITS,
  EMAIL_CONFIG,
} from '@/application/services/user-constants';
import {
  InvalidUserIdError,
  InvalidEmailError,
  InvalidFiltersError,
  InvalidUserRoleError,
  InvalidUserDeletionError,
} from '@/domain/errors/user-errors';

/**
 * IMPLEMENTATION of UserValidationService
 * This is an ADAPTER - implements the port defined in application layer
 */
export const createUserValidationService: UserValidationServiceFactory =
  (): UserValidationService => ({
    validateUserId: (userId: string): void => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (userId === null || userId === undefined) {
        throw new InvalidUserIdError('User ID cannot be null or undefined');
      }

      if (typeof userId !== 'string') {
        throw new InvalidUserIdError('User ID must be a string');
      }

      if (!userId || userId.trim().length === 0) {
        throw new InvalidUserIdError('User ID is required');
      }

      if (userId.length > USER_LIMITS.ID_MAX_LENGTH) {
        throw new InvalidUserIdError(
          `User ID cannot exceed ${USER_LIMITS.ID_MAX_LENGTH} characters`
        );
      }
    },

    validateEmail: (email: string): void => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (email === null || email === undefined) {
        throw new InvalidEmailError('Email cannot be null or undefined');
      }

      if (typeof email !== 'string') {
        throw new InvalidEmailError('Email must be a string');
      }

      if (!email || email.trim().length === 0) {
        throw new InvalidEmailError('Email is required');
      }

      const emailRegex = EMAIL_CONFIG.VALIDATION_REGEX;
      if (!emailRegex.test(email)) {
        throw new InvalidEmailError('Invalid email format');
      }

      if (email.length > USER_LIMITS.EMAIL_MAX_LENGTH) {
        throw new InvalidEmailError(
          `Email cannot exceed ${USER_LIMITS.EMAIL_MAX_LENGTH} characters`
        );
      }
    },

    validateListUsersFilters: (filters) => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (filters === null || filters === undefined) {
        throw new InvalidFiltersError('Filters cannot be null or undefined');
      }

      if (typeof filters !== 'object') {
        throw new InvalidFiltersError('Filters must be an object');
      }

      // ... rest of implementation
    },

    validateUserCreationRules: (name, email, companyId, role) => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (name === null || name === undefined) {
        throw new InvalidUserRoleError('Name cannot be null or undefined');
      }

      if (email === null || email === undefined) {
        throw new InvalidEmailError('Email cannot be null or undefined');
      }

      // ... rest of implementation
    },

    validateUserCanBeDeleted: (user) => {
      // ğŸ¯ ACTUAL IMPLEMENTATION HERE
      if (user === null || user === undefined) {
        throw new InvalidUserDeletionError('User cannot be null or undefined');
      }

      if (typeof user !== 'object') {
        throw new InvalidUserDeletionError('User must be an object');
      }

      // ... business rules implementation
    },
  });
```

```typescript
// âœ… CORRECT: src/infrastructure/services/notification-publisher.ts
// EXAMPLE OF EVENT PUBLISHER - ACTUAL IMPLEMENTATION

import type { NotificationPublisher } from '@/application/services/notification-publisher';
import type { EventPublisher } from '../event-publisher-client';

/**
 * IMPLEMENTATION of NotificationPublisher
 * This is an ADAPTER - implements the port defined in application layer
 */
export const notificationPublisher =
  (eventPublisher: EventPublisher): NotificationPublisher =>
  async (params): Promise<void> => {
    // ğŸ¯ ACTUAL IMPLEMENTATION HERE
    if (params.events.length === 0) {
      return;
    }

    const publishableEvents = params.events.map((event) => {
      return {
        metadata: {
          source: 'notification-service',
          eventType: 'notification-created',
          eventId: event.eventId,
          eventTimestamp: new Date(params.eventTimestamp).toISOString(),
          userId: params.userId,
          companyId: params.companyId,
          sessionId: params.sessionId,
        },
        data: {
          notification: event.notification,
          context: event.context,
        },
      };
    });

    await eventPublisher.publish(
      publishableEvents,
      `/companies/${params.companyId}/users/${params.userId}/notifications`
    );
  };
```

#### **ğŸ”§ Dependency Injection at Infrastructure Boundary**

```typescript
// âœ… CORRECT: src/infrastructure/http/handlers/user-handler.ts
// DEPENDENCY INJECTION HAPPENS HERE - AT THE INFRASTRUCTURE BOUNDARY

import type { UserValidationService } from '@/application/services/user-validation';
import type { UserUtilityService } from '@/application/services/user-utility';
import type { UserRepository } from '@/application/ports/user';

// Import IMPLEMENTATIONS from infrastructure
import { createUserValidationService } from '@/infrastructure/services/user-validation';
import { createUserUtilityService } from '@/infrastructure/services/user-utility';
import { createUserRepository } from '@/infrastructure/repositories/user-repository';

export const createUserHandler = (dependencies: {
  database: DatabaseClient;
  logger: Logger;
}) => {
  // ğŸ”§ DEPENDENCY INJECTION - COMPOSE IMPLEMENTATIONS
  const userRepository: UserRepository = createUserRepository(
    dependencies.database
  );
  const validationService: UserValidationService =
    createUserValidationService();
  const utilityService: UserUtilityService = createUserUtilityService();

  // ğŸ¯ COMPOSE USE CASES WITH INJECTED DEPENDENCIES
  const createUserUseCase = createUserUseCase(
    userRepository,
    validationService,
    utilityService
  );

  return async (request: UserRequest) => {
    return await createUserUseCase(request.body);
  };
};
```

```typescript
// âœ… CORRECT: Following dependency injection pattern
// DEPENDENCY INJECTION IN USE CASE COMPOSITION

const notificationPublisher = createNotificationPublisher(
  createEventPublisher(httpClient, logger)
);

const useCase = createUserNotificationUseCase(notificationPublisher);
```

#### **ğŸ¯ Use Cases: Pure Orchestration**

```typescript
// âœ… CORRECT: src/application/use-cases/create-user.ts
// USE CASES ORCHESTRATE CONTRACTS - NO IMPLEMENTATIONS

import type { UserRepository } from '@/application/ports/user';
import type { UserValidationService } from '@/application/services/user-validation';
import type { UserUtilityService } from '@/application/services/user-utility';

/**
 * Use case for creating users
 * Uses CONTRACTS/PORTS - never direct implementations
 */
export const createUserUseCase =
  (
    userRepository: UserRepository, // â† PORT (contract)
    validationService: UserValidationService, // â† PORT (contract)
    utilityService: UserUtilityService // â† PORT (contract)
  ) =>
  async (input: CreateUserInput): Promise<CreateUserResponse> => {
    // ğŸ¯ ORCHESTRATE USING CONTRACTS ONLY

    // Use validation contract
    validationService.validateUserCreationRules(
      input.name,
      input.email,
      input.companyId,
      input.role
    );

    // Use utility contract
    const userId = utilityService.generateUserId();
    const hashedPassword = utilityService.hashPassword(input.password);

    // Use repository contract
    return await userRepository.createUser({
      ...input,
      id: userId,
      password: hashedPassword,
    });
  };
```

#### **ğŸ“ Strict Directory Structure**

```
src/
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ services/           # ğŸ“‹ ONLY TYPE DEFINITIONS & CONTRACTS
â”‚   â”‚   â”œâ”€â”€ user-validation.ts         # export type UserValidationService
â”‚   â”‚   â”œâ”€â”€ user-utility.ts            # export type UserUtilityService
â”‚   â”‚   â”œâ”€â”€ order-processing.ts        # export type OrderProcessingService
â”‚   â”‚   â”œâ”€â”€ notification-publisher.ts  # export type NotificationPublisher
â”‚   â”‚   â””â”€â”€ user-constants.ts          # export const LIMITS, DEFAULTS (configuration)
â”‚   â”œâ”€â”€ ports/              # ğŸ“‹ REPOSITORY & EXTERNAL CONTRACTS
â”‚   â”‚   â”œâ”€â”€ user.ts                    # export interface UserRepository
â”‚   â”‚   â”œâ”€â”€ order.ts                   # export interface OrderRepository
â”‚   â”‚   â””â”€â”€ auth.ts                    # export interface AuthRepository
â”‚   â””â”€â”€ use-cases/          # ğŸ¯ ORCHESTRATION USING CONTRACTS
â”‚       â”œâ”€â”€ create-user.ts
â”‚       â”œâ”€â”€ process-order.ts
â”‚       â””â”€â”€ send-notification.ts
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ services/           # âš™ï¸ ACTUAL IMPLEMENTATIONS OF APPLICATION/SERVICES
â”‚   â”‚   â”œâ”€â”€ user-validation.ts         # implements UserValidationService
â”‚   â”‚   â”œâ”€â”€ user-utility.ts            # implements UserUtilityService
â”‚   â”‚   â”œâ”€â”€ order-processing.ts        # implements OrderProcessingService
â”‚   â”‚   â””â”€â”€ notification-publisher.ts  # implements NotificationPublisher
â”‚   â”œâ”€â”€ repositories/       # ğŸ’¾ ACTUAL IMPLEMENTATIONS OF APPLICATION/PORTS
â”‚   â”‚   â”œâ”€â”€ user-repository.ts         # implements UserRepository
â”‚   â”‚   â”œâ”€â”€ order-repository.ts        # implements OrderRepository
â”‚   â”‚   â””â”€â”€ auth-repository.ts         # implements AuthRepository
â”‚   â””â”€â”€ http/              # ğŸŒ HANDLERS WITH DEPENDENCY INJECTION
â”‚       â”œâ”€â”€ user-handler.ts            # composes & injects implementations
â”‚       â””â”€â”€ order-handler.ts           # composes & injects implementations
â”‚
â””â”€â”€ domain/                # ğŸ¯ PURE BUSINESS LOGIC
    â”œâ”€â”€ entities/           # Classes with behavior
    â”œâ”€â”€ value-objects/      # Immutable values
    â””â”€â”€ errors/            # Domain-specific exceptions
```

#### **ğŸš¨ CRITICAL VIOLATIONS TO AVOID**

```typescript
// âŒ ABSOLUTELY FORBIDDEN: Implementation in application layer
// src/application/services/user-validation.ts

export const createUserValidationService = () => {
  // ğŸš« THIS IS WRONG - NO IMPLEMENTATIONS IN APPLICATION LAYER
  const validateUserId = (userId: string): void => {
    if (!userId) {
      throw new Error('Invalid ID'); // âŒ IMPLEMENTATION CODE
    }
  };

  return { validateUserId }; // âŒ RETURNING IMPLEMENTATION
};
```

```typescript
// âŒ ABSOLUTELY FORBIDDEN: Direct implementation imports in use cases
// src/application/use-cases/create-user.ts

import { createUserValidationService } from '@/application/services/user-validation'; // âŒ WRONG

export const createUserUseCase = (repository: UserRepository) => {
  const validation = createUserValidationService(); // âŒ DIRECT INSTANTIATION
  // ...
};
```

```typescript
// âŒ ABSOLUTELY FORBIDDEN: Mixed contracts and implementations
// src/application/services/user-service.ts

export type UserService = {
  createUser: (input: CreateUserInput) => Promise<User>;
};

// ğŸš« THIS VIOLATES SEPARATION - IMPLEMENTATION IN SAME FILE AS CONTRACT
export const createUserService = (repo: UserRepository): UserService => ({
  createUser: async (input) => {
    // âŒ IMPLEMENTATION CODE IN APPLICATION LAYER
    return await repo.create(input);
  },
});
```

#### **âœ… CORRECT PATTERNS SUMMARY**

| Layer                       | Contains                      | Examples                                                          | Purpose                                 |
| --------------------------- | ----------------------------- | ----------------------------------------------------------------- | --------------------------------------- |
| **Application/Services**    | Types, interfaces, contracts  | `export type ValidationService`, `export type EventPublisher`     | Define what the app needs (PORTS)       |
| **Infrastructure/Services** | Implementations, real logic   | `export const createValidationService = (): ValidationService =>` | Implement what the app needs (ADAPTERS) |
| **Application/Use-Cases**   | Orchestration using contracts | Function that receives contracts as params                        | Business logic orchestration            |
| **Infrastructure/HTTP**     | Dependency injection          | Create & inject implementations into use cases                    | Wire everything together                |

#### **ğŸ¯ Benefits of This Strict Separation**

1. **True Dependency Inversion**: High-level modules (use cases) don't depend on low-level modules (implementations)
2. **Perfect Testability**: Can easily mock any contract for testing
3. **Swappable Implementations**: Can have multiple implementations of same contract
4. **Clear Boundaries**: Impossible to accidentally mix layers
5. **Hexagonal Compliance**: True ports & adapters pattern
6. **ISP Compliance**: Interface Segregation - each contract is focused

#### **ğŸ§ª Testing with This Pattern**

```typescript
// âœ… PERFECT TESTABILITY - Mock contracts easily
describe('createUserUseCase', () => {
  const mockValidationService: UserValidationService = {
    validateUserId: vi.fn(),
    validateEmail: vi.fn(),
    validateListUsersFilters: vi.fn(),
    validateUserCreationRules: vi.fn(),
    validateUserCanBeDeleted: vi.fn(),
  };

  const mockUtilityService: UserUtilityService = {
    generateUserId: vi.fn(() => 'test-id'),
    hashPassword: vi.fn(() => 'hashed-password'),
    generateToken: vi.fn(() => 'test-token'),
    validatePermissions: vi.fn(),
  };

  const mockRepository: UserRepository = {
    createUser: vi.fn(),
    findById: vi.fn(),
    findByEmail: vi.fn(),
    updateUser: vi.fn(),
    deleteUser: vi.fn(),
  };

  it('should create user successfully', async () => {
    // Perfect isolation - using only contracts
    const useCase = createUserUseCase(
      mockRepository,
      mockValidationService,
      mockUtilityService
    );

    const result = await useCase(validInput);

    expect(mockValidationService.validateUserCreationRules).toHaveBeenCalled();
    expect(mockUtilityService.generateUserId).toHaveBeenCalled();
    expect(mockRepository.createUser).toHaveBeenCalled();
  });
});
```

### Function-First Philosophy

**CRITICAL**: This project follows a **function-first approach** where:

- **Classes are ONLY used for**:
  - Domain entities with behavior
  - Rich value objects with validation
  - Domain events
  - Domain errors extending Error
- **Functions are used for EVERYTHING else**:
  - Use cases (factory functions)
  - Application services (factory functions)
  - Repositories (factory functions)
  - Infrastructure adapters (factory functions)
  - Utilities and helpers (pure functions)

- **Dependency injection is function-based**:
  - Dependencies are passed as function parameters
  - No constructor injection or class-based DI
  - Services return objects with methods
  - Easy to test and compose

```typescript
// âœ… Correct pattern: Function-based use case
export const createUser =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserInput): Promise<User> => {
    // Implementation
  };

// âŒ Incorrect pattern: Class-based use case
export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {} // âŒ Avoid
}
```

### Directory Structure

```
project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domain/                   # Pure business logic
â”‚   â”‚   â”œâ”€â”€ models/               # Domain entities (with Zod validation)
â”‚   â”‚   â”œâ”€â”€ value-objects/        # Immutable value objects
â”‚   â”‚   â”œâ”€â”€ events/               # Domain events
â”‚   â”‚   â”œâ”€â”€ errors/               # Domain-specific errors
â”‚   â”‚   â””â”€â”€ ports/                # Interfaces (ports) for repositories and external services
â”‚   â”‚
â”‚   â”œâ”€â”€ application/              # Use cases and orchestration
â”‚   â”‚   â”œâ”€â”€ use-cases/            # Business use-case implementations
â”‚   â”‚   â”œâ”€â”€ dto/                  # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ services/             # Application services (orchestrators)
â”‚   â”‚   â””â”€â”€ ports/                # Interfaces required by use cases (driven ports)
â”‚   â”‚
â”‚   â”œâ”€â”€ infrastructure/           # Concrete adapters
â”‚   â”‚   â”œâ”€â”€ persistence/          # Database adapters (ORMs, driversâ€¦)
â”‚   â”‚   â”œâ”€â”€ messaging/            # Message-queue adapters
â”‚   â”‚   â”œâ”€â”€ external/             # Third-party service adapters (APIs, SDKsâ€¦)
â”‚   â”‚   â””â”€â”€ di/                   # Dependency-injection container setup
â”‚   â”‚
â”‚   â”œâ”€â”€ interfaces/               # Driven adapters (entry points)
â”‚   â”‚   â”œâ”€â”€ http/                 # HTTP controllers, routes, middleware
â”‚   â”‚   â”œâ”€â”€ cli/                  # CLI commands
â”‚   â”‚   â”œâ”€â”€ grpc/                 # gRPC handlers
â”‚   â”‚   â””â”€â”€ events/               # Event listeners (Kafka, RabbitMQâ€¦)
â”‚   â”‚
â”‚   â”œâ”€â”€ shared/                   # Cross-cutting utilities
â”‚   â”‚   â”œâ”€â”€ config/               # Env-var loading, config schemas
â”‚   â”‚   â”œâ”€â”€ logger/               # Central logger (e.g. Pino, Winston)
â”‚   â”‚   â””â”€â”€ utils/                # Generic helpers (date utils, transformersâ€¦)
â”‚   â”‚
â”‚   â”œâ”€â”€ config/                   # Project configs (ORM, ESLint, Jestâ€¦)
â”‚   â”‚   â”œâ”€â”€ ormconfig.ts
â”‚   â”‚   â”œâ”€â”€ logger.config.ts
â”‚   â”‚   â””â”€â”€ â€¦
â”‚   â”‚
â”‚   â”œâ”€â”€ __fixtures__/             # Test fixtures and builders
â”‚   â””â”€â”€ index.ts                  # Application entry point
â”‚
â”œâ”€â”€ tests/                        # Integration & end-to-end tests
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”‚   â””â”€â”€ evaluations/
â”‚
â”œâ”€â”€ docs/                         # Documentation (architecture diagrams, OpenAPIâ€¦)
â”‚
â”œâ”€â”€ scripts/                      # Utility scripts (migrations, seedersâ€¦)
â”‚
â”œâ”€â”€ .env                          # Default environment variables
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

## ğŸ’» CODE STYLE & CONVENTIONS

### File Naming

- Use kebab-case for all files in ./src
- Each module should have meaningful descriptive names
- Tests: place .test.ts files next to implementation files
- Integration tests: use .integ-test.ts suffix
- E2E tests: use .e2e-test.ts suffix

### TypeScript Imports

- **CRITICAL**: Always use path aliases (@/) instead of relative imports (../ or ./)
- **CRITICAL**: Never add .js extensions to TypeScript imports
- Use configured path aliases:
  - `@/*` - Root src directory
  - `@adapters/*` - Adapter implementations
  - `@application/*` - Application layer
  - `@domain/*` - Domain layer
  - `@evaluations/*` - Evaluation tests
  - `@fixtures/*` - Test fixtures
- TypeScript handles extensions automatically during transpilation

### Import Patterns

```typescript
// âœ… Correct imports (use path aliases)
import { User } from '@domain/entities/user';
import { createUserProfile } from '@application/use-cases/createUserProfile';
import { getAuroraClient } from '@adapters/database/clients/auroraClient';
import { logger } from '@adapters/shared/logger';
import { config } from '@/config';

// âŒ Incorrect imports (relative paths)
import { User } from '../domain/entities/user';
import { createUserProfile } from './use-cases/createUserProfile';
import { getAuroraClient } from '../../adapters/database/clients/auroraClient';
```

### Entity & Schema Patterns

```typescript
// âœ… Use Zod schemas for validation
import { z } from 'zod';

export const userSchema = z.object({
  id: z.number(),
  companyId: z.number(),
  name: z.string().max(64),
  email: z.string().email(),
  // ... other fields
});

export type User = z.infer<typeof userSchema>;
```

### Use Case Patterns

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

## ğŸ§ª TESTING STRATEGY

### Test Architecture

- **Unit tests**: `npm run test:unit` (fast, isolated)
- **Integration tests**: `npm run test:integ` (with real dependencies)
- **E2E tests**: `npm run test:e2e` (full system tests)
- **Evaluation tests**: `npm run test:eval` (AI model evaluations)
- Use Vitest as testing framework

### Test Patterns

```typescript
// âœ… Use builders for test data
import { userBuilder } from '@fixtures/user.fixture';
import { randomNumber } from '@fixtures/utils.fixture';

describe('createUserProfile', () => {
  it('should create user profile successfully', async () => {
    // Arrange
    const user = userBuilder.build();
    const companyId = randomNumber();

    // Act
    const result = await useCase({ userId: user.id, companyId });

    // Assert
    expect(result.isSuccess).toBe(true);
  });
});
```

### Test File Organization

- Unit tests: `*.test.ts` next to implementation
- Integration tests: `*.integ-test.ts` in same directory
- E2E tests: `*.e2e-test.ts` in same directory
- Use `__fixtures__/` for shared test data and builders

## ğŸ› ï¸ CODE QUALITY TOOLS

### ESLint Configuration

- Uses TypeScript ESLint with strict rules
- Enforces arrow functions over function declarations
- No console.log allowed (use logger instead)

### Key ESLint Rules

```typescript
// âœ… Correct patterns
const useCase = (dependencies) => async (input) => {
  /* ... */
};

logger.info('Message', { context });

// âŒ Avoid these patterns
function useCase() {
  /* ... */
} // Use arrow functions
console.log('message'); // Use logger instead
```

## ğŸ”„ FUNCTIONAL PROGRAMMING PATTERNS

### Function-First Architecture

This project follows a **function-first approach** where classes are avoided in favor of functions, dependency injection, and TypeScript types.

#### When to Use Classes vs Functions

```typescript
// âœ… Use classes ONLY for domain entities and value objects
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string
  ) {}

  updateName(newName: string): User {
    return new User(this.id, this.email, newName);
  }
}

// âœ… Use classes for domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// âœ… Use FUNCTIONS for everything else: use cases, services, repositories
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

// âœ… Use TYPES/INTERFACES for contracts
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
}

// âŒ DON'T use classes for services, repositories, or use cases
export class UserService {
  constructor(private userRepository: UserRepository) {} // âŒ Avoid

  async createUser(input: CreateUserInput): Promise<User> {
    // âŒ Avoid this pattern
  }
}
```

#### Functional Dependency Injection

```typescript
// âœ… Function-based dependency injection
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
  },

  sendPasswordReset: async (email: string) => {
    // Implementation
  },
});

// âœ… Export type for dependency injection
export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;

// âŒ DON'T use class-based dependency injection
export class UserNotificationService {
  constructor(
    private userRepository: UserRepository, // âŒ Avoid
    private emailService: EmailService, // âŒ Avoid
    private logger: Logger // âŒ Avoid
  ) {}
}
```

#### Repository Pattern with Functions

```typescript
// âœ… Function-based repository implementation
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },
});

// âŒ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {} // âŒ Avoid

  async create(input: CreateUserInput): Promise<User> {
    // âŒ Avoid this pattern
  }
}
```

#### Use Case Pattern with Functions

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });

    // Business logic
    const user = await userRepository.create(input);

    return { success: true, userId: user.id };
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;

// âŒ DON'T use class-based use cases
export class CreateUserProfileUseCase {
  constructor(
    private userRepository: UserRepository, // âŒ Avoid
    private logger: Logger // âŒ Avoid
  ) {}

  async execute(
    input: CreateUserProfileInput
  ): Promise<CreateUserProfileResult> {
    // âŒ Avoid this pattern
  }
}
```

### Benefits of Function-First Approach

1. **Immutability**: Functions promote immutable data patterns
2. **Testability**: Easy to mock dependencies and test pure functions
3. **Composability**: Functions can be easily composed and combined
4. **Type Safety**: Full TypeScript support without class complexity
5. **Performance**: No class instantiation overhead
6. **Simplicity**: Less boilerplate code and mental overhead

### Prettier Configuration

- Single quotes, semicolons, 120 char width
- 4 spaces indentation, trailing commas
- Format with: `npm run format`

## ğŸ—ï¸ SPECIFIC PATTERNS

### Database Layer

```typescript
// âœ… Database service pattern
export const getUserById =
  (db: AuroraClient): GetUserById =>
  async (id: number): Promise<User | null> => {
    const result = await db.select().from(user).where(eq(user.id, id));
    return result.length > 0 ? toUser(result[0]) : null;
  };
```

### API Handlers

```typescript
// âœ… API handler pattern with middleware
export const apiHandler = middy(handler)
  .use(requestLogger())
  .use(errorHandler())
  .use(parser({ schema: requestSchema }));
```

### Service Handlers

```typescript
// âœ… Service handler pattern
export const processUserRequest =
  (useCase: ProcessUserUseCase) => async (event: ServiceEvent) => {
    const { userId, action } = requestSchema.parse(event.data);
    const result = await useCase({ userId, action });
    return { success: true, data: result };
  };
```

## ğŸ“¦ CONFIGURATION MANAGEMENT

### Environment Configuration

- Use `src/config.ts` for centralized configuration
- Support environment variables with defaults
- Type all configuration with TypeScript interfaces

```typescript
// âœ… Configuration pattern
export const config = {
  aurora: {
    auroraSecretArn: process.env.AURORA_SECRET_ARN ?? '',
  },
  appSync: {
    endpoint: process.env.APPSYNC_ENDPOINT ?? '',
    awsRegion: process.env.AWS_REGION ?? 'us-west-2',
  },
} as const;
```

## ğŸš€ BUILD & DEPLOYMENT

### Build Configuration

- Use TypeScript compiler for building and deployment
- Build: `npm run build` (runs tsc build)
- Validate: `npm run validate`
- Deploy with infrastructure as code templates

### TypeScript Configuration

- Target: ES2022, Module: Preserve
- Strict mode enabled with all checks
- Path aliases configured in tsconfig.json
- No emit (handled by SAM)

## ğŸ”„ DEVELOPMENT WORKFLOW

### Essential Commands

- `npm run compile` - TypeScript compilation check
- `npm run test` - Run all unit tests
- `npm run test:integ` - Run integration tests
- `npm run test:e2e` - Run end-to-end tests
- `npm run test:eval` - Run AI evaluation tests
- `npm run lint` - ESLint check with auto-fix
- `npm run format` - Format code with Prettier
- `npm run build` - Build

### Database Operations

- `npm run db:generate` - Generate migrations
- `npm run db:migrate` - Run migrations
- `npm run db:drop` - Drop database (development)

### Git Workflow

- Use conventional commits: `feat:`, `fix:`, `docs:`, etc.
- Pre-commit hooks run format, lint, and tests

## ğŸ¯ ARCHITECTURE LAYERS

### Domain Layer

- **Entities**: Business objects with identity (using classes with behavior)
- **Value Objects**: Immutable values (using classes for complex objects, types for simple ones)
- **Events**: Domain events (using classes for rich domain events)
- **Errors**: Domain-specific exceptions (using classes extending Error)

#### When to Use Classes in Domain Layer

```typescript
// âœ… Use classes for domain entities with behavior
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string,
    public readonly createdAt: Date
  ) {}

  updateName(newName: string): User {
    if (!newName.trim()) {
      throw new InvalidUserNameError('Name cannot be empty');
    }
    return new User(this.id, this.email, newName, this.createdAt);
  }

  isActive(): boolean {
    const now = new Date();
    const monthsInactive =
      (now.getTime() - this.createdAt.getTime()) / (30 * 24 * 60 * 60 * 1000);
    return monthsInactive < 12;
  }
}

// âœ… Use classes for rich value objects
export class WorkoutTarget {
  constructor(
    public readonly type: 'power' | 'pace' | 'heartRate',
    public readonly value: number,
    public readonly unit: string
  ) {
    this.validate();
  }

  private validate(): void {
    if (this.value <= 0) {
      throw new InvalidWorkoutTargetError('Target value must be positive');
    }
  }

  equals(other: WorkoutTarget): boolean {
    return (
      this.type === other.type &&
      this.value === other.value &&
      this.unit === other.unit
    );
  }
}

// âœ… Use classes for domain errors
export class InvalidUserNameError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidUserNameError';
  }
}

// âœ… Use classes for domain events
export class UserCreatedEvent {
  constructor(
    public readonly userId: number,
    public readonly email: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

// âœ… Use types for simple value objects
export type UserStatus = 'active' | 'inactive' | 'suspended';

// âœ… Use interfaces for domain contracts
export interface UserRepository {
  save(user: User): Promise<void>;
  findById(id: number): Promise<User | null>;
}
```

### Application Layer

- **Use Cases**: Business logic orchestration
- **Services**: Application services for complex operations
- **Repository Interfaces**: Contracts for data access
- **Errors**: Application-specific exceptions

### Adapters Layer

- **Database**: Aurora/DynamoDB clients and services
- **API**: REST/HTTP handlers and middleware
- **AI**: AI service integrations
- **Messaging**: Message queue publishers and consumers
- **Workflow**: Workflow orchestration services
- **External APIs**: Third-party service clients

## ğŸ›¡ï¸ ERROR HANDLING

### Error Patterns

```typescript
// âœ… Domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// âœ… Use case error handling
try {
  const result = await useCase(input);
  return result;
} catch (error) {
  logger.error('Use case failed', { error, input });
  throw error;
}
```

## ğŸ”§ DEPENDENCY INJECTION & ARCHITECTURE PATTERNS

### Dependency Injection Pattern

This project uses **function-based dependency injection** where dependencies are injected as function parameters,
creating a clean separation between layers.

#### Application Layer (Use Cases)

Use cases are **factory functions** that receive their dependencies as parameters and return the actual use case
function:

```typescript
// âœ… Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });
    const user = await userRepository.create(input);
    return { success: true, userId: user.id };
  };

// Export the type for dependency injection
export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

#### Application Services

Application services follow the same pattern and can depend on multiple repositories:

```typescript
// âœ… Application service factory pattern
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    if (!user) throw new UserNotFoundException(`User ${userId} not found`);

    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
    logger.info('Welcome email sent', { userId });
  },
});

export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;
```

#### Adapter Layer Implementation

Adapters implement the interfaces defined in the application layer:

```typescript
// âœ… Database adapter (implements UserRepository)
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },

  async findByEmail(email: string): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.email, email));
    return user ? toUser(user) : null;
  },
});

// âœ… External service adapter (implements EmailService)
export const createEmailService = (
  client: EmailClient,
  logger: Logger
): EmailService => ({
  async send(params: SendEmailParams): Promise<void> {
    try {
      await client.send(params);
      logger.info('Email sent successfully', { to: params.to });
    } catch (error) {
      logger.error('Failed to send email', { error, params });
      throw error;
    }
  },
});
```

#### Dependency Composition

Dependencies are composed at the application boundary (handlers, controllers):

```typescript
// âœ… Handler/Controller dependency composition
export const createUserHandler = (dependencies: {
  userRepository: UserRepository;
  emailService: EmailService;
  logger: Logger;
}) => {
  // Compose use cases with their dependencies
  const createUserUseCase = createUserProfile(
    dependencies.userRepository,
    dependencies.logger
  );

  const notificationService = userNotificationService(
    dependencies.userRepository,
    dependencies.emailService,
    dependencies.logger
  );

  return async (event: ApiEvent) => {
    const input = validateInput(event.body);
    const result = await createUserUseCase(input);

    // Side effects after main operation
    await notificationService.sendWelcomeEmail(result.userId);

    return { statusCode: 201, body: JSON.stringify(result) };
  };
};
```

#### Repository Interface Definition

Application layer defines contracts through TypeScript interfaces:

```typescript
// âœ… Repository interface (in application layer)
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  update(id: number, input: UpdateUserInput): Promise<User>;
  delete(id: number): Promise<void>;
}

// âœ… Service interface (in application layer)
export interface EmailService {
  send(params: SendEmailParams): Promise<void>;
  sendBatch(params: SendBatchEmailParams): Promise<void>;
}
```

#### Main Module Wiring

The main module (handler entry point) wires all dependencies together:

```typescript
// âœ… Main module dependency wiring
export const handler = async (event: ApiEvent) => {
  // Infrastructure setup
  const db = await createDatabaseClient();
  const emailClient = createEmailClient();
  const logger = createLogger();

  // Create adapters
  const userRepository = createUserRepository(db);
  const emailService = createEmailService(emailClient, logger);

  // Create handler with dependencies
  const userHandler = createUserHandler({
    userRepository,
    emailService,
    logger,
  });

  return await userHandler(event);
};
```

### Key Benefits of This Pattern

1. **Testability**: Easy to mock dependencies by passing test implementations
2. **Flexibility**: Can swap implementations without changing business logic
3. **Separation of Concerns**: Clean boundaries between layers
4. **Type Safety**: Full TypeScript support with interface contracts
5. **Composability**: Use cases can be composed into larger workflows

### Testing with Dependency Injection

```typescript
// âœ… Testing with mocked dependencies
describe('createUserProfile', () => {
  const mockUserRepository: UserRepository = {
    create: vi.fn(),
    findById: vi.fn(),
    findByEmail: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
  };

  const mockLogger: Logger = {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
  };

  it('should create user profile successfully', async () => {
    // Arrange
    const input = { name: 'John Doe', email: 'john@example.com' };
    const expectedUser = { id: 1, ...input };
    mockUserRepository.create.mockResolvedValue(expectedUser);

    const useCase = createUserProfile(mockUserRepository, mockLogger);

    // Act
    const result = await useCase(input);

    // Assert
    expect(result.success).toBe(true);
    expect(result.userId).toBe(1);
    expect(mockUserRepository.create).toHaveBeenCalledWith(input);
    expect(mockLogger.info).toHaveBeenCalledWith('Creating user profile', {
      input,
    });
  });
});
```

## ğŸ“Š MONITORING & LOGGING

### Logging Pattern

```typescript
// âœ… Structured logging
import { logger } from '@adapters/shared/logger';

logger.info('Operation started', { userId, companyId });
logger.error('Operation failed', { error, context });
```

### Tracing

- DataDog tracing enabled
- AWS X-Ray integration
- Performance monitoring for AI operations

## ğŸ”§ AI INTEGRATION

### AI Service Pattern

```typescript
// âœ… AI service integration
export const generateTopicContent =
  (aiClient: AiClient, logger: Logger) =>
  async (input: GenerateTopicContentInput): Promise<TopicContent> => {
    const prompt = buildPrompt(input);
    const response = await aiClient.generateText(prompt);
    return mapToTopicContent(response);
  };
```

## ğŸš« ANTI-PATTERNS TO AVOID

### Import & File System Anti-Patterns

- **Don't use relative imports** - Always use path aliases
- **Don't add .js extensions** to TypeScript imports
- **Don't use console.log** - Use structured logger
- **Don't hardcode configuration** - Use environment variables

### Function & Class Anti-Patterns

- **Don't use function declarations** - Use arrow functions
- **Don't use classes for services** - Use functions with dependency injection
- **Don't use classes for repositories** - Use factory functions
- **Don't use classes for use cases** - Use factory functions
- **Don't use class-based dependency injection** - Use function parameters
- **Don't use new keyword** - Except for domain entities and errors

### Architecture Anti-Patterns

- **Don't skip tests** - Maintain test coverage
- **Don't create circular dependencies** between layers
- **Don't mix business logic with infrastructure**
- **Don't use singletons** - Use dependency injection
- **Don't use static methods** - Use pure functions

### Examples of What to Avoid

```typescript
// âŒ DON'T use classes for application logic
export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(input: CreateUserInput): Promise<User> {
    return await this.userRepository.create(input);
  }
}

// âŒ DON'T use function declarations
function createUser(input: CreateUserInput): Promise<User> {
  // ...
}

// âŒ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {}

  async findById(id: number): Promise<User | null> {
    // ...
  }
}

// âŒ DON'T use singletons
export class Logger {
  private static instance: Logger;

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
}

// âŒ DON'T use static methods
export class UserHelpers {
  static validateEmail(email: string): boolean {
    // ...
  }
}

// âœ… DO use pure functions instead
export const validateEmail = (email: string): boolean => {
  // ...
};

// âœ… DO use function-based patterns
export const createUserService = (userRepository: UserRepository) => ({
  createUser: async (input: CreateUserInput): Promise<User> => {
    return await userRepository.create(input);
  },
});
```

## ğŸ¯ WHEN ADDING NEW FEATURES

1. **Start with domain**: Define entities, value objects, events
2. **Define use cases**: Create application layer logic
3. **Create adapters**: Implement infrastructure concerns
4. **Add resolvers/handlers**: Wire up API endpoints
5. **Write tests**: Unit, integration, and e2e tests
6. **Add evaluations**: For AI-related features
7. **Update documentation**: Keep schemas and docs current

## ğŸ“‹ SPECIFIC TECHNOLOGIES

### Database (Drizzle ORM)

```typescript
// âœ… Drizzle query pattern
const users = await db
  .select()
  .from(user)
  .where(and(eq(user.companyId, companyId), eq(user.isActive, true)));
```

### API Design

- Schema-first approach with code generation
- Typed handlers with input validation
- Real-time event processing support

### AI Services

- Centralized AI model instances
- Prompt engineering with evaluations
- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.

- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.

- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.

- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.
