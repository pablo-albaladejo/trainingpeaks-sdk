---
description: Cursor rules for TypeScript project
globs:
alwaysApply: true
---

# 🏗️ TYPESCRIPT PROJECT

## 🏗️ ARCHITECTURE DECISIONS

### Hexagonal Architecture (Clean Architecture)

- Use hexagonal architecture pattern for all modules
- Structure: domain/ → application/ → adapters/
- Domain layer: Pure business logic, entities, value objects, events
- Application layer: Use cases, services, repository interfaces
- Adapters layer: Infrastructure implementations (database, API clients, external services)

### Function-First Philosophy

**CRITICAL**: This project follows a **function-first approach** where:

- **Classes are ONLY used for**:
  - Domain entities with behavior
  - Rich value objects with validation
  - Domain events
  - Domain errors extending Error
- **Functions are used for EVERYTHING else**:
  - Use cases (factory functions)
  - Application services (factory functions)
  - Repositories (factory functions)
  - Infrastructure adapters (factory functions)
  - Utilities and helpers (pure functions)

- **Dependency injection is function-based**:
  - Dependencies are passed as function parameters
  - No constructor injection or class-based DI
  - Services return objects with methods
  - Easy to test and compose

```typescript
// ✅ Correct pattern: Function-based use case
export const createUser =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserInput): Promise<User> => {
    // Implementation
  };

// ❌ Incorrect pattern: Class-based use case
export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {} // ❌ Avoid
}
```

### Directory Structure

```
project-root/
├── src/
│   ├── domain/                   # Pure business logic
│   │   ├── models/               # Domain entities (with Zod validation)
│   │   ├── value-objects/        # Immutable value objects
│   │   ├── events/               # Domain events
│   │   ├── errors/               # Domain-specific errors
│   │   └── ports/                # Interfaces (ports) for repositories and external services
│   │
│   ├── application/              # Use cases and orchestration
│   │   ├── use-cases/            # Business use-case implementations
│   │   ├── dto/                  # Data Transfer Objects
│   │   ├── services/             # Application services (orchestrators)
│   │   └── ports/                # Interfaces required by use cases (driven ports)
│   │
│   ├── infrastructure/           # Concrete adapters
│   │   ├── persistence/          # Database adapters (ORMs, drivers…)
│   │   ├── messaging/            # Message-queue adapters
│   │   ├── external/             # Third-party service adapters (APIs, SDKs…)
│   │   └── di/                   # Dependency-injection container setup
│   │
│   ├── interfaces/               # Driven adapters (entry points)
│   │   ├── http/                 # HTTP controllers, routes, middleware
│   │   ├── cli/                  # CLI commands
│   │   ├── grpc/                 # gRPC handlers
│   │   └── events/               # Event listeners (Kafka, RabbitMQ…)
│   │
│   ├── shared/                   # Cross-cutting utilities
│   │   ├── config/               # Env-var loading, config schemas
│   │   ├── logger/               # Central logger (e.g. Pino, Winston)
│   │   └── utils/                # Generic helpers (date utils, transformers…)
│   │
│   ├── config/                   # Project configs (ORM, ESLint, Jest…)
│   │   ├── ormconfig.ts
│   │   ├── logger.config.ts
│   │   └── …
│   │
│   ├── __fixtures__/             # Test fixtures and builders
│   └── index.ts                  # Application entry point
│
├── tests/                        # Integration & end-to-end tests
│   ├── integration/
│   └── e2e/
│   └── evaluations/
│
├── docs/                         # Documentation (architecture diagrams, OpenAPI…)
│
├── scripts/                      # Utility scripts (migrations, seeders…)
│
├── .env                          # Default environment variables
├── package.json
├── tsconfig.json
└── README.md
```

## 💻 CODE STYLE & CONVENTIONS

### File Naming

- Use kebab-case for all files in ./src
- Each module should have meaningful descriptive names
- Tests: place .test.ts files next to implementation files
- Integration tests: use .integ-test.ts suffix
- E2E tests: use .e2e-test.ts suffix

### TypeScript Imports

- **CRITICAL**: Always use path aliases (@/) instead of relative imports (../ or ./)
- **CRITICAL**: Never add .js extensions to TypeScript imports
- Use configured path aliases:
  - `@/*` - Root src directory
  - `@adapters/*` - Adapter implementations
  - `@application/*` - Application layer
  - `@domain/*` - Domain layer
  - `@evaluations/*` - Evaluation tests
  - `@fixtures/*` - Test fixtures
- TypeScript handles extensions automatically during transpilation

### Import Patterns

```typescript
// ✅ Correct imports (use path aliases)
import { User } from '@domain/entities/user';
import { createUserProfile } from '@application/use-cases/createUserProfile';
import { getAuroraClient } from '@adapters/database/clients/auroraClient';
import { logger } from '@adapters/shared/logger';
import { config } from '@/config';

// ❌ Incorrect imports (relative paths)
import { User } from '../domain/entities/user';
import { createUserProfile } from './use-cases/createUserProfile';
import { getAuroraClient } from '../../adapters/database/clients/auroraClient';
```

### Entity & Schema Patterns

```typescript
// ✅ Use Zod schemas for validation
import { z } from 'zod';

export const userSchema = z.object({
  id: z.number(),
  companyId: z.number(),
  name: z.string().max(64),
  email: z.string().email(),
  // ... other fields
});

export type User = z.infer<typeof userSchema>;
```

### Use Case Patterns

```typescript
// ✅ Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

## 🧪 TESTING STRATEGY

### Test Architecture

- **Unit tests**: `npm run test:unit` (fast, isolated)
- **Integration tests**: `npm run test:integ` (with real dependencies)
- **E2E tests**: `npm run test:e2e` (full system tests)
- **Evaluation tests**: `npm run test:eval` (AI model evaluations)
- Use Vitest as testing framework

### Test Patterns

```typescript
// ✅ Use builders for test data
import { userBuilder } from '@fixtures/user.fixture';
import { randomNumber } from '@fixtures/utils.fixture';

describe('createUserProfile', () => {
  it('should create user profile successfully', async () => {
    // Arrange
    const user = userBuilder.build();
    const companyId = randomNumber();

    // Act
    const result = await useCase({ userId: user.id, companyId });

    // Assert
    expect(result.isSuccess).toBe(true);
  });
});
```

### Test File Organization

- Unit tests: `*.test.ts` next to implementation
- Integration tests: `*.integ-test.ts` in same directory
- E2E tests: `*.e2e-test.ts` in same directory
- Use `__fixtures__/` for shared test data and builders

## 🛠️ CODE QUALITY TOOLS

### ESLint Configuration

- Uses TypeScript ESLint with strict rules
- Enforces arrow functions over function declarations
- No console.log allowed (use logger instead)

### Key ESLint Rules

```typescript
// ✅ Correct patterns
const useCase = (dependencies) => async (input) => {
  /* ... */
};

logger.info('Message', { context });

// ❌ Avoid these patterns
function useCase() {
  /* ... */
} // Use arrow functions
console.log('message'); // Use logger instead
```

## 🔄 FUNCTIONAL PROGRAMMING PATTERNS

### Function-First Architecture

This project follows a **function-first approach** where classes are avoided in favor of functions, dependency injection, and TypeScript types.

#### When to Use Classes vs Functions

```typescript
// ✅ Use classes ONLY for domain entities and value objects
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string
  ) {}

  updateName(newName: string): User {
    return new User(this.id, this.email, newName);
  }
}

// ✅ Use classes for domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// ✅ Use FUNCTIONS for everything else: use cases, services, repositories
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    // Implementation
  };

// ✅ Use TYPES/INTERFACES for contracts
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
}

// ❌ DON'T use classes for services, repositories, or use cases
export class UserService {
  constructor(private userRepository: UserRepository) {} // ❌ Avoid

  async createUser(input: CreateUserInput): Promise<User> {
    // ❌ Avoid this pattern
  }
}
```

#### Functional Dependency Injection

```typescript
// ✅ Function-based dependency injection
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
  },

  sendPasswordReset: async (email: string) => {
    // Implementation
  },
});

// ✅ Export type for dependency injection
export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;

// ❌ DON'T use class-based dependency injection
export class UserNotificationService {
  constructor(
    private userRepository: UserRepository, // ❌ Avoid
    private emailService: EmailService, // ❌ Avoid
    private logger: Logger // ❌ Avoid
  ) {}
}
```

#### Repository Pattern with Functions

```typescript
// ✅ Function-based repository implementation
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },
});

// ❌ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {} // ❌ Avoid

  async create(input: CreateUserInput): Promise<User> {
    // ❌ Avoid this pattern
  }
}
```

#### Use Case Pattern with Functions

```typescript
// ✅ Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });

    // Business logic
    const user = await userRepository.create(input);

    return { success: true, userId: user.id };
  };

export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;

// ❌ DON'T use class-based use cases
export class CreateUserProfileUseCase {
  constructor(
    private userRepository: UserRepository, // ❌ Avoid
    private logger: Logger // ❌ Avoid
  ) {}

  async execute(
    input: CreateUserProfileInput
  ): Promise<CreateUserProfileResult> {
    // ❌ Avoid this pattern
  }
}
```

### Benefits of Function-First Approach

1. **Immutability**: Functions promote immutable data patterns
2. **Testability**: Easy to mock dependencies and test pure functions
3. **Composability**: Functions can be easily composed and combined
4. **Type Safety**: Full TypeScript support without class complexity
5. **Performance**: No class instantiation overhead
6. **Simplicity**: Less boilerplate code and mental overhead

### Prettier Configuration

- Single quotes, semicolons, 120 char width
- 4 spaces indentation, trailing commas
- Format with: `npm run format`

## 🏗️ SPECIFIC PATTERNS

### Database Layer

```typescript
// ✅ Database service pattern
export const getUserById =
  (db: AuroraClient): GetUserById =>
  async (id: number): Promise<User | null> => {
    const result = await db.select().from(user).where(eq(user.id, id));
    return result.length > 0 ? toUser(result[0]) : null;
  };
```

### API Handlers

```typescript
// ✅ API handler pattern with middleware
export const apiHandler = middy(handler)
  .use(requestLogger())
  .use(errorHandler())
  .use(parser({ schema: requestSchema }));
```

### Service Handlers

```typescript
// ✅ Service handler pattern
export const processUserRequest =
  (useCase: ProcessUserUseCase) => async (event: ServiceEvent) => {
    const { userId, action } = requestSchema.parse(event.data);
    const result = await useCase({ userId, action });
    return { success: true, data: result };
  };
```

## 📦 CONFIGURATION MANAGEMENT

### Environment Configuration

- Use `src/config.ts` for centralized configuration
- Support environment variables with defaults
- Type all configuration with TypeScript interfaces

```typescript
// ✅ Configuration pattern
export const config = {
  aurora: {
    auroraSecretArn: process.env.AURORA_SECRET_ARN ?? '',
  },
  appSync: {
    endpoint: process.env.APPSYNC_ENDPOINT ?? '',
    awsRegion: process.env.AWS_REGION ?? 'us-west-2',
  },
} as const;
```

## 🚀 BUILD & DEPLOYMENT

### Build Configuration

- Use TypeScript compiler for building and deployment
- Build: `npm run build` (runs tsc build)
- Validate: `npm run validate`
- Deploy with infrastructure as code templates

### TypeScript Configuration

- Target: ES2022, Module: Preserve
- Strict mode enabled with all checks
- Path aliases configured in tsconfig.json
- No emit (handled by SAM)

## 🔄 DEVELOPMENT WORKFLOW

### Essential Commands

- `npm run compile` - TypeScript compilation check
- `npm run test` - Run all unit tests
- `npm run test:integ` - Run integration tests
- `npm run test:e2e` - Run end-to-end tests
- `npm run test:eval` - Run AI evaluation tests
- `npm run lint` - ESLint check with auto-fix
- `npm run format` - Format code with Prettier
- `npm run build` - Build

### Database Operations

- `npm run db:generate` - Generate migrations
- `npm run db:migrate` - Run migrations
- `npm run db:drop` - Drop database (development)

### Git Workflow

- Use conventional commits: `feat:`, `fix:`, `docs:`, etc.
- Pre-commit hooks run format, lint, and tests

## 🎯 ARCHITECTURE LAYERS

### Domain Layer

- **Entities**: Business objects with identity (using classes with behavior)
- **Value Objects**: Immutable values (using classes for complex objects, types for simple ones)
- **Events**: Domain events (using classes for rich domain events)
- **Errors**: Domain-specific exceptions (using classes extending Error)

#### When to Use Classes in Domain Layer

```typescript
// ✅ Use classes for domain entities with behavior
export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    public readonly name: string,
    public readonly createdAt: Date
  ) {}

  updateName(newName: string): User {
    if (!newName.trim()) {
      throw new InvalidUserNameError('Name cannot be empty');
    }
    return new User(this.id, this.email, newName, this.createdAt);
  }

  isActive(): boolean {
    const now = new Date();
    const monthsInactive =
      (now.getTime() - this.createdAt.getTime()) / (30 * 24 * 60 * 60 * 1000);
    return monthsInactive < 12;
  }
}

// ✅ Use classes for rich value objects
export class WorkoutTarget {
  constructor(
    public readonly type: 'power' | 'pace' | 'heartRate',
    public readonly value: number,
    public readonly unit: string
  ) {
    this.validate();
  }

  private validate(): void {
    if (this.value <= 0) {
      throw new InvalidWorkoutTargetError('Target value must be positive');
    }
  }

  equals(other: WorkoutTarget): boolean {
    return (
      this.type === other.type &&
      this.value === other.value &&
      this.unit === other.unit
    );
  }
}

// ✅ Use classes for domain errors
export class InvalidUserNameError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InvalidUserNameError';
  }
}

// ✅ Use classes for domain events
export class UserCreatedEvent {
  constructor(
    public readonly userId: number,
    public readonly email: string,
    public readonly occurredAt: Date = new Date()
  ) {}
}

// ✅ Use types for simple value objects
export type UserStatus = 'active' | 'inactive' | 'suspended';

// ✅ Use interfaces for domain contracts
export interface UserRepository {
  save(user: User): Promise<void>;
  findById(id: number): Promise<User | null>;
}
```

### Application Layer

- **Use Cases**: Business logic orchestration
- **Services**: Application services for complex operations
- **Repository Interfaces**: Contracts for data access
- **Errors**: Application-specific exceptions

### Adapters Layer

- **Database**: Aurora/DynamoDB clients and services
- **API**: REST/HTTP handlers and middleware
- **AI**: AI service integrations
- **Messaging**: Message queue publishers and consumers
- **Workflow**: Workflow orchestration services
- **External APIs**: Third-party service clients

## 🛡️ ERROR HANDLING

### Error Patterns

```typescript
// ✅ Domain errors
export class UserNotFoundException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UserNotFoundException';
  }
}

// ✅ Use case error handling
try {
  const result = await useCase(input);
  return result;
} catch (error) {
  logger.error('Use case failed', { error, input });
  throw error;
}
```

## 🔧 DEPENDENCY INJECTION & ARCHITECTURE PATTERNS

### Dependency Injection Pattern

This project uses **function-based dependency injection** where dependencies are injected as function parameters,
creating a clean separation between layers.

#### Application Layer (Use Cases)

Use cases are **factory functions** that receive their dependencies as parameters and return the actual use case
function:

```typescript
// ✅ Use case factory pattern
export const createUserProfile =
  (userRepository: UserRepository, logger: Logger) =>
  async (input: CreateUserProfileInput): Promise<CreateUserProfileResult> => {
    logger.info('Creating user profile', { input });
    const user = await userRepository.create(input);
    return { success: true, userId: user.id };
  };

// Export the type for dependency injection
export type CreateUserProfileUseCase = ReturnType<typeof createUserProfile>;
```

#### Application Services

Application services follow the same pattern and can depend on multiple repositories:

```typescript
// ✅ Application service factory pattern
export const userNotificationService = (
  userRepository: UserRepository,
  emailService: EmailService,
  logger: Logger
) => ({
  sendWelcomeEmail: async (userId: number) => {
    const user = await userRepository.findById(userId);
    if (!user) throw new UserNotFoundException(`User ${userId} not found`);

    await emailService.send({
      to: user.email,
      template: 'welcome',
      data: { name: user.name },
    });
    logger.info('Welcome email sent', { userId });
  },
});

export type UserNotificationService = ReturnType<
  typeof userNotificationService
>;
```

#### Adapter Layer Implementation

Adapters implement the interfaces defined in the application layer:

```typescript
// ✅ Database adapter (implements UserRepository)
export const createUserRepository = (db: DatabaseClient): UserRepository => ({
  async create(input: CreateUserInput): Promise<User> {
    const [user] = await db.insert(userTable).values(input).returning();
    return toUser(user);
  },

  async findById(id: number): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.id, id));
    return user ? toUser(user) : null;
  },

  async findByEmail(email: string): Promise<User | null> {
    const [user] = await db
      .select()
      .from(userTable)
      .where(eq(userTable.email, email));
    return user ? toUser(user) : null;
  },
});

// ✅ External service adapter (implements EmailService)
export const createEmailService = (
  client: EmailClient,
  logger: Logger
): EmailService => ({
  async send(params: SendEmailParams): Promise<void> {
    try {
      await client.send(params);
      logger.info('Email sent successfully', { to: params.to });
    } catch (error) {
      logger.error('Failed to send email', { error, params });
      throw error;
    }
  },
});
```

#### Dependency Composition

Dependencies are composed at the application boundary (handlers, controllers):

```typescript
// ✅ Handler/Controller dependency composition
export const createUserHandler = (dependencies: {
  userRepository: UserRepository;
  emailService: EmailService;
  logger: Logger;
}) => {
  // Compose use cases with their dependencies
  const createUserUseCase = createUserProfile(
    dependencies.userRepository,
    dependencies.logger
  );

  const notificationService = userNotificationService(
    dependencies.userRepository,
    dependencies.emailService,
    dependencies.logger
  );

  return async (event: ApiEvent) => {
    const input = validateInput(event.body);
    const result = await createUserUseCase(input);

    // Side effects after main operation
    await notificationService.sendWelcomeEmail(result.userId);

    return { statusCode: 201, body: JSON.stringify(result) };
  };
};
```

#### Repository Interface Definition

Application layer defines contracts through TypeScript interfaces:

```typescript
// ✅ Repository interface (in application layer)
export interface UserRepository {
  create(input: CreateUserInput): Promise<User>;
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  update(id: number, input: UpdateUserInput): Promise<User>;
  delete(id: number): Promise<void>;
}

// ✅ Service interface (in application layer)
export interface EmailService {
  send(params: SendEmailParams): Promise<void>;
  sendBatch(params: SendBatchEmailParams): Promise<void>;
}
```

#### Main Module Wiring

The main module (handler entry point) wires all dependencies together:

```typescript
// ✅ Main module dependency wiring
export const handler = async (event: ApiEvent) => {
  // Infrastructure setup
  const db = await createDatabaseClient();
  const emailClient = createEmailClient();
  const logger = createLogger();

  // Create adapters
  const userRepository = createUserRepository(db);
  const emailService = createEmailService(emailClient, logger);

  // Create handler with dependencies
  const userHandler = createUserHandler({
    userRepository,
    emailService,
    logger,
  });

  return await userHandler(event);
};
```

### Key Benefits of This Pattern

1. **Testability**: Easy to mock dependencies by passing test implementations
2. **Flexibility**: Can swap implementations without changing business logic
3. **Separation of Concerns**: Clean boundaries between layers
4. **Type Safety**: Full TypeScript support with interface contracts
5. **Composability**: Use cases can be composed into larger workflows

### Testing with Dependency Injection

```typescript
// ✅ Testing with mocked dependencies
describe('createUserProfile', () => {
  const mockUserRepository: UserRepository = {
    create: vi.fn(),
    findById: vi.fn(),
    findByEmail: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
  };

  const mockLogger: Logger = {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
  };

  it('should create user profile successfully', async () => {
    // Arrange
    const input = { name: 'John Doe', email: 'john@example.com' };
    const expectedUser = { id: 1, ...input };
    mockUserRepository.create.mockResolvedValue(expectedUser);

    const useCase = createUserProfile(mockUserRepository, mockLogger);

    // Act
    const result = await useCase(input);

    // Assert
    expect(result.success).toBe(true);
    expect(result.userId).toBe(1);
    expect(mockUserRepository.create).toHaveBeenCalledWith(input);
    expect(mockLogger.info).toHaveBeenCalledWith('Creating user profile', {
      input,
    });
  });
});
```

## 📊 MONITORING & LOGGING

### Logging Pattern

```typescript
// ✅ Structured logging
import { logger } from '@adapters/shared/logger';

logger.info('Operation started', { userId, companyId });
logger.error('Operation failed', { error, context });
```

### Tracing

- DataDog tracing enabled
- AWS X-Ray integration
- Performance monitoring for AI operations

## 🔧 AI INTEGRATION

### AI Service Pattern

```typescript
// ✅ AI service integration
export const generateTopicContent =
  (aiClient: AiClient, logger: Logger) =>
  async (input: GenerateTopicContentInput): Promise<TopicContent> => {
    const prompt = buildPrompt(input);
    const response = await aiClient.generateText(prompt);
    return mapToTopicContent(response);
  };
```

## 🚫 ANTI-PATTERNS TO AVOID

### Import & File System Anti-Patterns

- **Don't use relative imports** - Always use path aliases
- **Don't add .js extensions** to TypeScript imports
- **Don't use console.log** - Use structured logger
- **Don't hardcode configuration** - Use environment variables

### Function & Class Anti-Patterns

- **Don't use function declarations** - Use arrow functions
- **Don't use classes for services** - Use functions with dependency injection
- **Don't use classes for repositories** - Use factory functions
- **Don't use classes for use cases** - Use factory functions
- **Don't use class-based dependency injection** - Use function parameters
- **Don't use new keyword** - Except for domain entities and errors

### Architecture Anti-Patterns

- **Don't skip tests** - Maintain test coverage
- **Don't create circular dependencies** between layers
- **Don't mix business logic with infrastructure**
- **Don't use singletons** - Use dependency injection
- **Don't use static methods** - Use pure functions

### Examples of What to Avoid

```typescript
// ❌ DON'T use classes for application logic
export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(input: CreateUserInput): Promise<User> {
    return await this.userRepository.create(input);
  }
}

// ❌ DON'T use function declarations
function createUser(input: CreateUserInput): Promise<User> {
  // ...
}

// ❌ DON'T use class-based repositories
export class UserRepository {
  constructor(private db: DatabaseClient) {}

  async findById(id: number): Promise<User | null> {
    // ...
  }
}

// ❌ DON'T use singletons
export class Logger {
  private static instance: Logger;

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
}

// ❌ DON'T use static methods
export class UserHelpers {
  static validateEmail(email: string): boolean {
    // ...
  }
}

// ✅ DO use pure functions instead
export const validateEmail = (email: string): boolean => {
  // ...
};

// ✅ DO use function-based patterns
export const createUserService = (userRepository: UserRepository) => ({
  createUser: async (input: CreateUserInput): Promise<User> => {
    return await userRepository.create(input);
  },
});
```

## 🎯 WHEN ADDING NEW FEATURES

1. **Start with domain**: Define entities, value objects, events
2. **Define use cases**: Create application layer logic
3. **Create adapters**: Implement infrastructure concerns
4. **Add resolvers/handlers**: Wire up API endpoints
5. **Write tests**: Unit, integration, and e2e tests
6. **Add evaluations**: For AI-related features
7. **Update documentation**: Keep schemas and docs current

## 📋 SPECIFIC TECHNOLOGIES

### Database (Drizzle ORM)

```typescript
// ✅ Drizzle query pattern
const users = await db
  .select()
  .from(user)
  .where(and(eq(user.companyId, companyId), eq(user.isActive, true)));
```

### API Design

- Schema-first approach with code generation
- Typed handlers with input validation
- Real-time event processing support

### AI Services

- Centralized AI model instances
- Prompt engineering with evaluations
- Structured output parsing with Zod

This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
comprehensive testing, and AI-driven features.
