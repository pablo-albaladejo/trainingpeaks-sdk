---
alwaysApply: true
description: Hexagonal architecture patterns and strict separation of concerns for TypeScript projects
---

# ðŸ—ï¸ Hexagonal Architecture (Clean Architecture)

## ðŸš¨ **CRITICAL: Strict Ports & Adapters Separation**

The application layer MUST ONLY contain **contracts, types, and interfaces**.
The infrastructure layer MUST contain **all implementations**.

### **ðŸ“‹ Application Layer: ONLY Definitions & Contracts**

All services in `src/application/services/` MUST use **individual function types** instead of grouped interface patterns.

#### **âœ… CORRECT: Individual Function Types**

```typescript
// âœ… CORRECT: src/application/services/user-validation.ts
export type validateUserId = (userId: string) => void;
export type validateEmail = (email: string) => void;
export type validateListUsersFilters = (filters: Filters) => void;
```

#### **âŒ INCORRECT: Grouped Interface Pattern**

```typescript
// âŒ WRONG: src/application/services/user-validation.ts
export type UserValidationService = {
  validateUserId: (userId: string) => void;
  validateEmail: (email: string) => void;
  validateListUsersFilters: (filters: Filters) => void;
};
```

### **âš™ï¸ Infrastructure Layer: ONLY Implementations**

All implementations in `src/infrastructure/services/` MUST be factory functions that receive dependencies as parameters and return the exact implementation of the individual function type.

#### **âœ… CORRECT: Individual Function Exports**

```typescript
// âœ… CORRECT: src/infrastructure/services/user-validation.ts
import type {
  validateUserId,
  validateEmail,
} from '@/application/services/user-validation';

export const validateUserId: validateUserId = (userId: string): void => {
  // implementation
};

export const validateEmail: validateEmail = (email: string): void => {
  // implementation
};
```

#### **âŒ ABSOLUTELY FORBIDDEN: Grouped Factory Functions**

```typescript
// âŒ WRONG: src/infrastructure/services/user-validation.ts
export const createUserValidationService = (dependencies) => ({
  validateUserId: (userId: string): void => {
    /* */
  },
  validateEmail: (email: string): void => {
    /* */
  },
});
```

### **ðŸ”§ For Functions That Need Dependencies**

```typescript
// âœ… CORRECT: src/infrastructure/services/user-validation.ts
export const validateUserId =
  (logger: Logger): validateUserId =>
  (userId: string): void => {
    // implementation
  };
```

## ðŸŽ¯ **Use Cases: Pure Orchestration**

Use cases orchestrate contracts - never direct implementations:

```typescript
// âœ… CORRECT: src/application/use-cases/create-user.ts
export const createUserUseCase =
  (
    userRepository: UserRepository, // â† PORT (contract)
    validationService: UserValidationService, // â† PORT (contract)
    utilityService: UserUtilityService // â† PORT (contract)
  ) =>
  async (input: CreateUserInput): Promise<CreateUserResponse> => {
    // ðŸŽ¯ ORCHESTRATE USING CONTRACTS ONLY
    validationService.validateUserCreationRules(input);
    const userId = utilityService.generateUserId();
    return await userRepository.createUser({ ...input, id: userId });
  };
```

## ðŸ“ **Strict Directory Structure**

```
src/
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ services/           # ðŸ“‹ ONLY TYPE DEFINITIONS & CONTRACTS
â”‚   â”œâ”€â”€ ports/              # ðŸ“‹ REPOSITORY & EXTERNAL CONTRACTS
â”‚   â””â”€â”€ use-cases/          # ðŸŽ¯ ORCHESTRATION USING CONTRACTS
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ services/           # âš™ï¸ ACTUAL IMPLEMENTATIONS OF APPLICATION/SERVICES
â”‚   â”œâ”€â”€ repositories/       # ðŸ’¾ ACTUAL IMPLEMENTATIONS OF APPLICATION/PORTS
â”‚   â””â”€â”€ http/              # ðŸŒ HANDLERS WITH DEPENDENCY INJECTION
â””â”€â”€ domain/                # ðŸŽ¯ PURE BUSINESS LOGIC
    â”œâ”€â”€ entities/           # Classes with behavior
    â”œâ”€â”€ value-objects/      # Immutable values
    â””â”€â”€ errors/            # Domain-specific exceptions
```

## ðŸš¨ **CRITICAL VIOLATIONS TO AVOID**

```typescript
// âŒ ABSOLUTELY FORBIDDEN: Implementation in application layer
export const createUserValidationService = () => {
  const validateUserId = (userId: string): void => {
    if (!userId) throw new Error('Invalid ID'); // âŒ IMPLEMENTATION CODE
  };
  return { validateUserId }; // âŒ RETURNING IMPLEMENTATION
};

// âŒ ABSOLUTELY FORBIDDEN: Direct implementation imports in use cases
import { createUserValidationService } from '@/application/services/user-validation'; // âŒ WRONG

// âŒ ABSOLUTELY FORBIDDEN: Mixed contracts and implementations
export type UserService = { createUser: (input) => Promise<User> };
export const createUserService = (repo) => ({
  // âŒ IMPLEMENTATION IN SAME FILE
  createUser: async (input) => {
    return await repo.create(input);
  },
});
```

## ðŸ§ª **Testing with This Pattern**

```typescript
// âœ… PERFECT TESTABILITY - Mock contracts easily
describe('createUserUseCase', () => {
  const mockValidationService: UserValidationService = {
    validateUserId: vi.fn(),
    validateEmail: vi.fn(),
    validateListUsersFilters: vi.fn(),
    validateUserCreationRules: vi.fn(),
    validateUserCanBeDeleted: vi.fn(),
  };

  it('should create user successfully', async () => {
    const useCase = createUserUseCase(
      mockRepository,
      mockValidationService,
      mockUtilityService
    );
    const result = await useCase(validInput);
    expect(mockValidationService.validateUserCreationRules).toHaveBeenCalled();
  });
});
```

## ðŸŽ¯ **Benefits of This Strict Separation**

1. **True Dependency Inversion**: High-level modules don't depend on low-level modules
2. **Perfect Testability**: Can easily mock any contract for testing
3. **Swappable Implementations**: Can have multiple implementations of same contract
4. **Clear Boundaries**: Impossible to accidentally mix layers
5. **Hexagonal Compliance**: True ports & adapters pattern
6. **ISP Compliance**: Interface Segregation - each contract is focused
   This project follows hexagonal architecture with modern TypeScript patterns, emphasizing clean separation of concerns,
   comprehensive testing, and AI-driven features.
