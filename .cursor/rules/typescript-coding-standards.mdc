---
description: TypeScript coding standards and best practices for npm libraries
globs: **/*.ts,**/*.js,**/*.mjs
alwaysApply: false
---

# TypeScript Coding Standards for NPM Libraries

## Code Style and Formatting

### General Principles

- Use TypeScript strict mode
- Prefer explicit types over implicit inference
- Use meaningful variable and function names
- Follow consistent naming conventions

### Naming Conventions

```typescript
// Types: PascalCase with descriptive names (preferred over interfaces)
type UserRepository = {
  readonly findById: (id: string) => Promise<User | null>;
};
type CreateUserInput = {
  readonly email: string;
  readonly name: string;
};

// Function types: PascalCase (preferred over classes)
type CreateUser = (input: CreateUserInput) => Promise<User>;
type ValidateEmail = (email: string) => void;

// Constants: UPPER_SNAKE_CASE
const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_TIMEOUT = 5000;

// Functions: camelCase
function createUserImpl() {}
function validateEmailImpl() {}
```

### Type Definitions

#### Public API Types

```typescript
// Export public types from dedicated files (prefer types over interfaces)
// types.ts
export type User = {
  readonly id: string;
  readonly email: string;
  readonly name: string;
};

export type CreateUserOptions = {
  readonly email: string;
  readonly name: string;
  readonly validateEmail?: boolean;
};

// Function types for services
export type CreateUser = (options: CreateUserOptions) => Promise<User>;
export type FindUser = (id: string) => Promise<User | null>;
```

#### Internal Types

```typescript
// Use internal types for implementation details
type InternalUserData = {
  readonly id: string;
  readonly email: string;
  readonly name: string;
  readonly createdAt: Date;
  readonly updatedAt: Date;
};
```

## Function Design

### Function Signatures

```typescript
// Prefer explicit return types for public APIs
export function createUser(options: CreateUserOptions): Promise<User> {
  // implementation
}

// Use overloads for complex function signatures
export function processData(input: string): string;
export function processData(input: number): number;
export function processData(input: string | number): string | number {
  // implementation
}
```

### Parameter Design

```typescript
// Use options objects for functions with many parameters
type ProcessOptions = {
  readonly timeout?: number;
  readonly retries?: number;
  readonly validate?: boolean;
};

// Function type definition
export type ProcessWithOptions = (options?: ProcessOptions) => Promise<void>;

// Implementation
export const processWithOptions: ProcessWithOptions = async (options = {}) => {
  const { timeout = 5000, retries = 3, validate = true } = options;
  // implementation
};
```

### Error Handling

```typescript
// Define custom error types
export class ValidationError extends Error {
  constructor(
    message: string,
    public readonly field: string
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

// Use Result pattern for operations that can fail
export type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

export function safeOperation(): Result<string, ValidationError> {
  try {
    return { success: true, data: 'result' };
  } catch (error) {
    return { success: false, error: new ValidationError('Failed', 'field') };
  }
}
```

## Functional Design (Preferred over Classes)

### Immutable Data Structures

```typescript
// Prefer immutable data types for domain entities
export type User = {
  readonly id: string;
  readonly email: string;
  readonly name: string;
};

// Pure functions for entity operations
export const createUser = (id: string, email: string, name: string): User => ({
  id,
  email,
  name,
});

export const updateUserName = (user: User, newName: string): User => ({
  ...user,
  name: newName,
});
```

### Function Composition and Dependency Injection

```typescript
// Individual function types (preferred over grouped objects)
export type FindUser = (id: string) => Promise<User | null>;
export type SaveUser = (user: User) => Promise<void>;
export type ValidateEmail = (email: string) => void;
export type ValidateName = (name: string) => void;
export type CreateUserService = (input: CreateUserInput) => Promise<User>;

// Factory function that injects individual functions
export const createUserService = (
  findUser: FindUser,
  saveUser: SaveUser,
  validateEmail: ValidateEmail,
  validateName: ValidateName
): CreateUserService =>
  async (input: CreateUserInput): Promise<User> => {
    validateEmail(input.email);
    validateName(input.name);
    const user = createUser(generateId(), input.email, input.name);
    await saveUser(user);
    return user;
  };
```

## Module Organization

### Barrel Exports

```typescript
// index.ts - Main library exports
export { UserService } from './services/UserService';
export { User } from './entities/User';
export { CreateUserInput } from './types';
export { ValidationError } from './errors';

// Avoid re-exporting internal implementation details
```

### Internal Modules

```typescript
// Use internal modules for implementation details
// internal/validation.ts
export function validateEmail(email: string): boolean {
  // internal implementation
}

// Only export what's needed for the public API
export { validateEmail } from './internal/validation';
```

## Async/Await Patterns

### Promise Handling

```typescript
// Use async/await consistently
export async function fetchUser(id: string): Promise<User> {
  try {
    const response = await httpClient.get(`/users/${id}`);
    return User.fromResponse(response);
  } catch (error) {
    throw new UserNotFoundError(`User ${id} not found`);
  }
}

// Handle multiple promises efficiently
export async function fetchMultipleUsers(ids: string[]): Promise<User[]> {
  const promises = ids.map((id) => fetchUser(id));
  return Promise.all(promises);
}
```

### Error Propagation

```typescript
// Preserve error context when re-throwing
export async function processUser(id: string): Promise<void> {
  try {
    const user = await fetchUser(id);
    await validateUser(user);
  } catch (error) {
    // Add context to the error
    throw new ProcessingError(`Failed to process user ${id}`, { cause: error });
  }
}
```

## Generic Types

### Generic Constraints

```typescript
// Use constraints to limit generic types
interface Identifiable {
  id: string;
}

export function findById<T extends Identifiable>(
  items: T[],
  id: string
): T | undefined {
  return items.find((item) => item.id === id);
}
```

### Generic Utilities

```typescript
// Create reusable generic utilities
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;
```

## Configuration and Options

### Configuration Objects

```typescript
// Use configuration types for library setup
export type LibraryConfig = {
  readonly apiKey?: string;
  readonly baseUrl?: string;
  readonly timeout?: number;
  readonly retries?: number;
};

type ResolvedConfig = {
  readonly apiKey: string;
  readonly baseUrl: string;
  readonly timeout: number;
  readonly retries: number;
};

// Factory function instead of class
export const createLibraryClient = (config: LibraryConfig = {}) => {
  const resolvedConfig: ResolvedConfig = {
    apiKey: config.apiKey ?? process.env.API_KEY ?? '',
    baseUrl: config.baseUrl ?? 'https://api.example.com',
    timeout: config.timeout ?? 5000,
    retries: config.retries ?? 3,
  };

  return {
    config: resolvedConfig,
    // Client methods as functions
  };
};
```

## Testing Patterns

### Mocking

```typescript
// Use types for easy mocking
export type HttpClient = {
  readonly get: <T>(url: string) => Promise<T>;
  readonly post: <T>(url: string, data: unknown) => Promise<T>;
};

// Individual function type definitions (preferred)
export type HttpGet = <T>(url: string) => Promise<T>;
export type HttpPost = <T>(url: string, data: unknown) => Promise<T>;

// In tests - mock individual functions
const mockHttpGet: HttpGet = vi.fn();
const mockHttpPost: HttpPost = vi.fn();

// Or mock the grouped type if needed
const mockHttpClient: HttpClient = {
  get: vi.fn(),
  post: vi.fn(),
};
```

### Test Utilities

```typescript
// Create test utilities for common patterns
export function createMockUser(overrides: Partial<User> = {}): User {
  return {
    id: 'test-id',
    email: 'test@example.com',
    name: 'Test User',
    ...overrides,
  };
}
```

## Performance Considerations

### Lazy Evaluation

```typescript
// Use lazy evaluation for expensive operations
export class ExpensiveService {
  private _cache: Map<string, Promise<Result>> | null = null;

  private get cache(): Map<string, Promise<Result>> {
    if (!this._cache) {
      this._cache = new Map();
    }
    return this._cache;
  }
}
```

### Memory Management

```typescript
// Implement proper cleanup for resources
export class ResourceManager {
  private resources: Set<Disposable> = new Set();

  addResource(resource: Disposable): void {
    this.resources.add(resource);
  }

  dispose(): void {
    for (const resource of this.resources) {
      resource.dispose();
    }
    this.resources.clear();
  }
}
```

## Documentation

### JSDoc Comments

````typescript
/**
 * Creates a new user with the provided information.
 *
 * @param options - The user creation options
 * @param options.email - The user's email address
 * @param options.name - The user's display name
 * @param options.validateEmail - Whether to validate the email format (default: true)
 *
 * @returns A promise that resolves to the created user
 *
 * @throws {ValidationError} When the email format is invalid
 * @throws {UserExistsError} When a user with the email already exists
 *
 * @example
 * ```typescript
 * const user = await createUser({
 *   email: 'john@example.com',
 *   name: 'John Doe'
 * });
 * ```
 */
export async function createUser(options: CreateUserOptions): Promise<User> {
  // implementation
}
````

### Type Documentation

```typescript
/**
 * Configuration options for the library client.
 */
export type LibraryConfig = {
  /** API key for authentication */
  readonly apiKey?: string;
  /** Base URL for API requests */
  readonly baseUrl?: string;
  /** Request timeout in milliseconds */
  readonly timeout?: number;
};
```
