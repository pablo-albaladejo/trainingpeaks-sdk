---
description: Clean architecture principles and project structure for npm libraries
globs: **/*.ts,**/*.js,**/*.mjs
alwaysApply: false
---

# NPM Library Project Architecture

## Overview

This project follows Clean Architecture principles adapted for npm libraries, with clear separation of concerns and
dependency inversion.

This is the TrainingPeaks SDK - a comprehensive TypeScript SDK for TrainingPeaks API integration. For complete product context, business objectives, target market, and feature overview, see [PRODUCT.md](../../PRODUCT.md).

## Project Structure

```
src/
‚îú‚îÄ‚îÄ adapters/           # External integrations and implementations
‚îÇ   ‚îú‚îÄ‚îÄ http/          # HTTP clients and API integrations
‚îÇ   ‚îú‚îÄ‚îÄ storage/       # Database, file system, or external storage
‚îÇ   ‚îú‚îÄ‚îÄ validation/    # Input/output validation schemas
‚îÇ   ‚îî‚îÄ‚îÄ serialization/ # Data transformation and serialization
‚îú‚îÄ‚îÄ application/       # Application business logic
‚îÇ   ‚îú‚îÄ‚îÄ services/      # Use case implementations
‚îÇ   ‚îú‚îÄ‚îÄ repositories/  # Repository interfaces
‚îÇ   ‚îî‚îÄ‚îÄ useCases/      # Business use cases
‚îú‚îÄ‚îÄ domain/           # Core business logic and entities
‚îÇ   ‚îú‚îÄ‚îÄ entities/     # Domain entities
‚îÇ   ‚îú‚îÄ‚îÄ valueObjects/ # Value objects
‚îÇ   ‚îú‚îÄ‚îÄ events/       # Domain events
‚îÇ   ‚îî‚îÄ‚îÄ repositories/ # Repository interfaces
‚îî‚îÄ‚îÄ shared/           # Shared utilities and types
    ‚îú‚îÄ‚îÄ types/        # Common TypeScript types
    ‚îú‚îÄ‚îÄ utils/        # Utility functions
    ‚îî‚îÄ‚îÄ errors/       # Error handling
```

## Architecture Principles

### 1. Dependency Inversion

- Domain layer has no dependencies on external frameworks
- Application layer depends only on domain interfaces
- Adapters implement domain interfaces

### 2. Hexagonal Architecture (Ports & Adapters)

#### **üö® CRITICAL: Strict Ports & Adapters Separation**

The application layer MUST contain orchestration logic implemented strictly as pure functions and function type aliases (contracts/ports). Ports are defined in the domain/application layer and implemented by adapters. **Rule: No direct infrastructure access ‚Äî orchestrate via injected ports.**

**Must move to adapters layer:** time/clocks, randomness/PRNG, network I/O, file I/O, databases, logging, OS/env access, process exit, user input, external services, global mutable state, system calls.

**Allowed in application layer:** pure domain constructors, pure data transforms, validation, composition/orchestration functions, function type aliases/contracts, deterministic helpers.

**‚úÖ DO (Application Layer):**
- Call injected port function types: `await saveUser(user)`
- Return pure values: `return { success: true, user }`
- Keep orchestration logic deterministic
- Define ports: `export type SaveUser = (user: User) => Promise<void>`
- Import from domain: `import { User } from '@domain/entities/User'`

**‚ùå DON'T (Application Layer):**
- Import adapters: `import { HttpClient } from '@adapters/http'`
- Call APIs directly: `axios.post('/users', userData)`
- Perform side-effecting I/O inside application functions
- Access filesystem: `fs.readFileSync('config.json')`
- Direct database calls: `db.users.create(user)`

**üîí ESLint Enforcement:**
Add to your ESLint config to block adapter imports in application layer:
```json
{
  "rules": {
    "no-restricted-imports": [
      "error",
      {
        "patterns": [
          {
            "group": ["**/adapters/**", "@adapters/**"],
            "importNames": ["*"],
            "message": "Application layer cannot import from adapters. Use injected port interfaces."
          }
        ]
      }
    ]
  },
  "overrides": [
    {
      "files": ["src/application/**/*.ts"],
      "rules": {
        "no-restricted-imports": [
          "error",
          {
            "patterns": ["**/adapters/**", "@adapters/**"],
            "message": "Application layer must use injected ports, not direct adapter imports"
          }
        ]
      }
    }
  ]
}
```

**Where to define:**
- **Ports/Contracts**: `src/domain/` or `src/application/ports/`
- **Implementations**: `src/adapters/**`

**CI Integration:** Add this ESLint rule to your CI pipeline. Builds will fail on violations, forcing authors to use injected ports for all external interactions.

**Dependency Injection Pattern:** Ports are owned and defined by the application layer. Adapters implement those ports and encapsulate effects. Application-layer functions remain pure and only orchestrate by invoking injected port interfaces, while adapters perform the actual effects such as network, filesystem, or database access.

#### **üìã Application Layer: ONLY Definitions & Contracts**

All services in `src/application/services/` MUST use **individual function types** instead of grouped interface
patterns.

```typescript
// ‚úÖ CORRECT: src/application/services/user-validation.ts
export type validateUserId = (userId: string) => void;
export type validateEmail = (email: string) => void;
export type validateListUsersFilters = (filters: Filters) => void;
```

```typescript
// ‚ùå INCORRECT: Grouped Interface Pattern
export type UserValidationService = {
  validateUserId: (userId: string) => void;
  validateEmail: (email: string) => void;
  validateListUsersFilters: (filters: Filters) => void;
};
```

#### **‚öôÔ∏è Adapters Layer: ONLY Implementations**

Implementations in `src/adapters/services/` that require dependencies MUST be factory functions that receive dependencies as parameters and return the exact implementation of the individual function type. Functions with no dependencies can be implemented as plain functions.

```typescript
// ‚úÖ CORRECT: src/adapters/services/user-validation.ts
import type {
  validateUserId,
  validateEmail,
} from '@/application/services/user-validation';

export const validateUserId: validateUserId = (userId: string): void => {
  // implementation
};

export const validateEmail: validateEmail = (email: string): void => {
  // implementation
};
```

```typescript
// ‚ùå ABSOLUTELY FORBIDDEN: Grouped Factory Functions
export const createUserValidationService = (dependencies) => ({
  validateUserId: (userId: string): void => {
    /* */
  },
  validateEmail: (email: string): void => {
    /* */
  },
});
```

#### **üîß For Functions That Need Dependencies**

```typescript
// ‚úÖ CORRECT: src/adapters/services/user-validation.ts
export const validateUserId =
  (logger: Logger): validateUserId =>
  (userId: string): void => {
    // implementation
  };
```

### 2. Separation of Concerns

- **Domain**: Pure business logic, no external dependencies
- **Application**: Orchestrates use cases, depends on domain
- **Adapters**: External integrations, implements domain interfaces

### 3. Repository Pattern

- Define interfaces in domain layer
- Implement concrete repositories in adapters layer
- Use dependency injection to pass repositories to services

## Key Patterns

### Entity Design

```typescript
// Domain entities as immutable data structures with pure functions
export type User = {
  readonly id: UserId;
  readonly email: Email;
  readonly name: string;
};

// Business logic as pure functions
export const createUser = (id: UserId, email: Email, name: string): User => ({
  id,
  email,
  name,
});

export const updateUserName = (user: User, newName: string): User => ({
  ...user,
  name: newName,
});
```

### Repository Types

```typescript
// Define individual function types in domain layer
export type FindUserById = (id: UserId) => Promise<User | null>;
export type SaveUser = (user: User) => Promise<void>;
```

### Use Case Implementation

#### **üéØ Use Cases: Pure Orchestration**

Use cases orchestrate contracts - never direct implementations:

```typescript
// ‚úÖ CORRECT: src/application/use-cases/create-user.ts
import { createEmail } from '@domain/valueObjects/email';

export const createUserUseCase =
  (
    saveUser: SaveUser, // ‚Üê PORT (function type)
    validateEmail: ValidateEmail, // ‚Üê PORT (function type)
    generateUserId: GenerateUserId // ‚Üê PORT (function type)
  ) =>
  async (input: CreateUserInput): Promise<CreateUserResponse> => {
    // üéØ ORCHESTRATE USING FUNCTION CONTRACTS ONLY
    const email = createEmail(input.email); // Create Email VO from domain
    const userId = generateUserId();
    const user = createUser(userId, email, input.name);
    await saveUser(user);
    return { user };
  };
```

#### **üß™ Testing with This Pattern**

```typescript
// ‚úÖ PERFECT TESTABILITY - Mock individual functions easily
describe('createUserUseCase', () => {
  const mockFindUserById: FindUserById = vi.fn();
  const mockSaveUser: SaveUser = vi.fn();
  const mockValidateUserId: validateUserId = vi.fn();
  const mockValidateEmail: validateEmail = vi.fn();
  const mockGenerateUserId: generateUserId = vi.fn();

  it('should create user successfully', async () => {
    const useCase = createUserUseCase(
      mockFindUserById,
      mockSaveUser,
      mockValidateUserId,
      mockValidateEmail,
      mockGenerateUserId
    );
    const result = await useCase(validInput);
    expect(mockValidateUserId).toHaveBeenCalled();
  });
});
```

#### **‚ùå INCORRECT: Traditional Class Pattern**

```typescript
// ‚ùå WRONG: Using classes and grouped interfaces
export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(input: CreateUserInput): Promise<User> {
    const user = new User(input.id, input.email, input.name);
    await this.userRepository.save(user);
    return user;
  }
}

// ‚ùå ALSO WRONG: Grouped interface pattern
export type UserRepository = {
  findById(id: UserId): Promise<User | null>;
  save(user: User): Promise<void>;
};
```

### Adapter Implementation

```typescript
// Adapters layer - implements domain function types as pure functions
export const createFindUserById = (httpClient: HttpClient): FindUserById =>
  async (id: UserId): Promise<User | null> => {
    const response = await httpClient.get(`/users/${id.value}`);
    return response ? createUserFromResponse(response) : null;
  };

export const createSaveUser = (httpClient: HttpClient): SaveUser =>
  async (user: User): Promise<void> => {
    await httpClient.post('/users', userToApiFormat(user));
  };

// Helper functions for data transformation
const createUserFromResponse = (response: ApiResponse): User => {
  const userId = createUserId(response.id);
  const email = createEmail(response.email);
  return createUser(userId, email, response.name);
};

const userToApiFormat = (user: User) => ({
  id: user.id.value,
  email: user.email.value,
  name: user.name,
});
```

## Library Export Structure

### Main Entry Points

- `index.ts` - Main library exports
- `types.ts` - Public TypeScript types
- `errors.ts` - Public error classes

### Module Organization

```typescript
// index.ts
export { UserService } from './application/services/UserService';
export { User } from './domain/entities/User';
export { UserRepository } from './domain/repositories/UserRepository';
export { CreateUserInput } from './application/useCases/CreateUser';
```

## Configuration Management

### Environment Configuration

- Use environment variables for configuration
- Provide sensible defaults
- Validate configuration on startup

### Feature Flags

- Implement feature flags for experimental features
- Use configuration-based feature toggles
- Support runtime feature flag changes

## Error Handling

### Domain Errors

- Define specific error types in domain layer
- Use meaningful error messages
- Include error codes for programmatic handling

### Application Errors

- Wrap domain errors with context
- Provide user-friendly error messages
- Log errors with appropriate levels

## Testing Strategy

### Unit Tests

- Test domain entities and value objects
- Mock repositories in use case tests
- Test business logic in isolation

### Integration Tests

- Test repository implementations
- Test use case integration
- Test external service integrations

### Contract Tests

- Test public API contracts
- Ensure backward compatibility
- Validate type exports

## Performance Considerations

### Lazy Loading

- Implement lazy loading for heavy dependencies
- Use dynamic imports for optional features
- Minimize bundle size

### Caching

- Implement appropriate caching strategies
- Use memoization for expensive operations
- Consider cache invalidation strategies

### Memory Management

- Avoid memory leaks in long-running processes
- Use weak references where appropriate
- Implement proper cleanup methods
