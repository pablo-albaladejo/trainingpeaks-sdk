---
description: Clean architecture principles and project structure for npm libraries
globs: **/*.ts,**/*.js,**/*.mjs
alwaysApply: false
---

# NPM Library Project Architecture

## Overview

This project follows Clean Architecture principles adapted for npm libraries, with clear separation of concerns and
dependency inversion.

This is the TrainingPeaks SDK - a comprehensive TypeScript SDK for TrainingPeaks API integration. For complete product context, business objectives, target market, and feature overview, see [PRODUCT.md](../../PRODUCT.md).

## Project Structure

```
src/
‚îú‚îÄ‚îÄ adapters/           # External integrations and implementations
‚îÇ   ‚îú‚îÄ‚îÄ http/          # HTTP clients and API integrations
‚îÇ   ‚îú‚îÄ‚îÄ storage/       # Database, file system, or external storage
‚îÇ   ‚îú‚îÄ‚îÄ validation/    # Input/output validation schemas
‚îÇ   ‚îî‚îÄ‚îÄ serialization/ # Data transformation and serialization
‚îú‚îÄ‚îÄ application/       # Application business logic
‚îÇ   ‚îú‚îÄ‚îÄ services/      # Use case implementations
‚îÇ   ‚îú‚îÄ‚îÄ repositories/  # Repository interfaces
‚îÇ   ‚îî‚îÄ‚îÄ useCases/      # Business use cases
‚îú‚îÄ‚îÄ domain/           # Core business logic and entities
‚îÇ   ‚îú‚îÄ‚îÄ entities/     # Domain entities
‚îÇ   ‚îú‚îÄ‚îÄ valueObjects/ # Value objects
‚îÇ   ‚îú‚îÄ‚îÄ events/       # Domain events
‚îÇ   ‚îî‚îÄ‚îÄ repositories/ # Repository interfaces
‚îî‚îÄ‚îÄ shared/           # Shared utilities and types
    ‚îú‚îÄ‚îÄ types/        # Common TypeScript types
    ‚îú‚îÄ‚îÄ utils/        # Utility functions
    ‚îî‚îÄ‚îÄ errors/       # Error handling
```

## Architecture Principles

### 1. Dependency Inversion

- Domain layer has no dependencies on external frameworks
- Application layer depends only on domain interfaces
- Adapters implement domain interfaces

### 2. Hexagonal Architecture (Ports & Adapters)

#### **üö® CRITICAL: Strict Ports & Adapters Separation**

The application layer MUST contain orchestration logic implemented as pure functions, contracts, types, and interfaces, but no external or side-effecting implementations. The adapters layer MUST contain all external and side-effecting implementations.

#### **üìã Application Layer: ONLY Definitions & Contracts**

All services in `src/application/services/` MUST use **individual function types** instead of grouped interface
patterns.

```typescript
// ‚úÖ CORRECT: src/application/services/user-validation.ts
export type validateUserId = (userId: string) => void;
export type validateEmail = (email: string) => void;
export type validateListUsersFilters = (filters: Filters) => void;
```

```typescript
// ‚ùå INCORRECT: Grouped Interface Pattern
export type UserValidationService = {
  validateUserId: (userId: string) => void;
  validateEmail: (email: string) => void;
  validateListUsersFilters: (filters: Filters) => void;
};
```

#### **‚öôÔ∏è Adapters Layer: ONLY Implementations**

Implementations in `src/adapters/services/` that require dependencies MUST be factory functions that receive dependencies as parameters and return the exact implementation of the individual function type. Functions with no dependencies can be implemented as plain functions.

```typescript
// ‚úÖ CORRECT: src/adapters/services/user-validation.ts
import type {
  validateUserId,
  validateEmail,
} from '@/application/services/user-validation';

export const validateUserId: validateUserId = (userId: string): void => {
  // implementation
};

export const validateEmail: validateEmail = (email: string): void => {
  // implementation
};
```

```typescript
// ‚ùå ABSOLUTELY FORBIDDEN: Grouped Factory Functions
export const createUserValidationService = (dependencies) => ({
  validateUserId: (userId: string): void => {
    /* */
  },
  validateEmail: (email: string): void => {
    /* */
  },
});
```

#### **üîß For Functions That Need Dependencies**

```typescript
// ‚úÖ CORRECT: src/adapters/services/user-validation.ts
export const validateUserId =
  (logger: Logger): validateUserId =>
  (userId: string): void => {
    // implementation
  };
```

### 2. Separation of Concerns

- **Domain**: Pure business logic, no external dependencies
- **Application**: Orchestrates use cases, depends on domain
- **Adapters**: External integrations, implements domain interfaces

### 3. Repository Pattern

- Define interfaces in domain layer
- Implement concrete repositories in adapters layer
- Use dependency injection to pass repositories to services

## Key Patterns

### Entity Design

```typescript
// Domain entities as immutable data structures with pure functions
export type User = {
  readonly id: UserId;
  readonly email: Email;
  readonly name: string;
};

// Business logic as pure functions
export const createUser = (id: UserId, email: Email, name: string): User => ({
  id,
  email,
  name,
});

export const updateUserName = (user: User, newName: string): User => ({
  ...user,
  name: newName,
});
```

### Repository Types

```typescript
// Define individual function types in domain layer
export type FindUserById = (id: UserId) => Promise<User | null>;
export type SaveUser = (user: User) => Promise<void>;
```

### Use Case Implementation

#### **üéØ Use Cases: Pure Orchestration**

Use cases orchestrate contracts - never direct implementations:

```typescript
// ‚úÖ CORRECT: src/application/use-cases/create-user.ts
export const createUserUseCase =
  (
    findUserById: FindUserById, // ‚Üê PORT (function type)
    saveUser: SaveUser, // ‚Üê PORT (function type)
    validateUserId: validateUserId, // ‚Üê PORT (function type)
    validateEmail: validateEmail, // ‚Üê PORT (function type)
    generateUserId: generateUserId // ‚Üê PORT (function type)
  ) =>
  async (input: CreateUserInput): Promise<CreateUserResponse> => {
    // üéØ ORCHESTRATE USING FUNCTION CONTRACTS ONLY
    validateUserId(input.id);
    validateEmail(input.email);
    const userId = generateUserId();
    const user = createUser(userId, input.email, input.name);
    await saveUser(user);
    return { user };
  };
```

#### **üß™ Testing with This Pattern**

```typescript
// ‚úÖ PERFECT TESTABILITY - Mock individual functions easily
describe('createUserUseCase', () => {
  const mockFindUserById: FindUserById = vi.fn();
  const mockSaveUser: SaveUser = vi.fn();
  const mockValidateUserId: validateUserId = vi.fn();
  const mockValidateEmail: validateEmail = vi.fn();
  const mockGenerateUserId: generateUserId = vi.fn();

  it('should create user successfully', async () => {
    const useCase = createUserUseCase(
      mockFindUserById,
      mockSaveUser,
      mockValidateUserId,
      mockValidateEmail,
      mockGenerateUserId
    );
    const result = await useCase(validInput);
    expect(mockValidateUserId).toHaveBeenCalled();
  });
});
```

#### **‚ùå INCORRECT: Traditional Class Pattern**

```typescript
// ‚ùå WRONG: Using classes and grouped interfaces
export class CreateUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(input: CreateUserInput): Promise<User> {
    const user = new User(input.id, input.email, input.name);
    await this.userRepository.save(user);
    return user;
  }
}

// ‚ùå ALSO WRONG: Grouped interface pattern
export type UserRepository = {
  findById(id: UserId): Promise<User | null>;
  save(user: User): Promise<void>;
};
```

### Adapter Implementation

```typescript
// Adapters layer - implements domain function types as pure functions
export const createFindUserById = (httpClient: HttpClient): FindUserById =>
  async (id: UserId): Promise<User | null> => {
    const response = await httpClient.get(`/users/${id.value}`);
    return response ? createUserFromResponse(response) : null;
  };

export const createSaveUser = (httpClient: HttpClient): SaveUser =>
  async (user: User): Promise<void> => {
    await httpClient.post('/users', userToApiFormat(user));
  };

// Helper functions for data transformation
const createUserFromResponse = (response: ApiResponse): User =>
  createUser(response.id, response.email, response.name);

const userToApiFormat = (user: User) => ({
  id: user.id.value,
  email: user.email.value,
  name: user.name,
});
```

## Library Export Structure

### Main Entry Points

- `index.ts` - Main library exports
- `types.ts` - Public TypeScript types
- `errors.ts` - Public error classes

### Module Organization

```typescript
// index.ts
export { UserService } from './application/services/UserService';
export { User } from './domain/entities/User';
export { UserRepository } from './domain/repositories/UserRepository';
export { CreateUserInput } from './application/useCases/CreateUser';
```

## Configuration Management

### Environment Configuration

- Use environment variables for configuration
- Provide sensible defaults
- Validate configuration on startup

### Feature Flags

- Implement feature flags for experimental features
- Use configuration-based feature toggles
- Support runtime feature flag changes

## Error Handling

### Domain Errors

- Define specific error types in domain layer
- Use meaningful error messages
- Include error codes for programmatic handling

### Application Errors

- Wrap domain errors with context
- Provide user-friendly error messages
- Log errors with appropriate levels

## Testing Strategy

### Unit Tests

- Test domain entities and value objects
- Mock repositories in use case tests
- Test business logic in isolation

### Integration Tests

- Test repository implementations
- Test use case integration
- Test external service integrations

### Contract Tests

- Test public API contracts
- Ensure backward compatibility
- Validate type exports

## Performance Considerations

### Lazy Loading

- Implement lazy loading for heavy dependencies
- Use dynamic imports for optional features
- Minimize bundle size

### Caching

- Implement appropriate caching strategies
- Use memoization for expensive operations
- Consider cache invalidation strategies

### Memory Management

- Avoid memory leaks in long-running processes
- Use weak references where appropriate
- Implement proper cleanup methods
